<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpages%2F4a17b156%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Code]]></title>
    <url>%2Fpages%2F806683c5%2F</url>
    <content type="text"><![CDATA[Code test. 123((name) =&gt; &#123; console.log(`Hello $&#123;name&#125;!`);&#125;)('JavaScript');]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Readme]]></title>
    <url>%2Fpages%2F809983c5%2F</url>
    <content type="text"><![CDATA[山中荆溪白石出，天寒红叶稀。 山路元无雨，空翠湿人衣。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Win10配置免安装MySQL.md]]></title>
    <url>%2Fpages%2F8b6ca6bc%2F</url>
    <content type="text"><![CDATA[下载文件：到 MySQL 官网https://dev.mysql.com/downloads/mysql/下载免安装版本: DOWNLOADS → MySQL Community Server → Windows (x86, 64-bit), ZIP Archive 创建配置文件：将下载的 ZIP 文件解压至想要安装 MySQL 的文件夹，创建 mysql.ini 配置文件，保存退出。 12345678910111213141516[mysql]#设置mysql客户端默认字符集default-character-set = utf8[mysqld]#设置3306端口port = 3306# 设置mysql的安装目录basedir = C:\APPS\MySQL\mysql-5.7.18-winx64# 设置mysql数据库的数据的存放目录datadir = C:\APPS\MySQL\mysql-5.7.18-winx64\data# 允许最大连接数max_connections = 200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server = utf8# 创建新表时将使用的默认存储引擎default-storage-engine = INNODB 设置环境变量：右键桌面计算机→属性→高级系统设置→环境变量→系统变量Path→添加 MySQL 的bin目录路径，例如：C:\APPS\MySQL\mysql-5.7.18-winx64\bin 保存退出。 安装MySQL服务：a. 以管理员模式打开命令行窗口，安装MySQL服务： 1mysqld -install b. 初始化data目录： 1mysqld –-initialize c. 启动MySQL服务： 1net start MySQL d. 用户登录： 1mysql -u root -p e. 输入密码： 初始随机密码存在于data目录下.err结尾的文件中，初始随机密码为root@localhost:后面的字符，例如：rCTmkIr:K65t 1A temporary password is generated for root@localhost: rCTmkIr:K65t ​]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle基础]]></title>
    <url>%2Fpages%2F691946d1%2F</url>
    <content type="text"><![CDATA[Roay/app/build.gradle 这个文件是app文件夹下这个Module的gradle配置文件，也可以算是整个项目最主要的gradle配置文件。 ​ 文件内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 声明是Android程序apply plugin: 'com.android.application'android &#123; // 编译SDK的版本 compileSdkVersion 21 // build tools的版本 buildToolsVersion "21.1.1" defaultConfig &#123; // 应用的包名 applicationId "ly.roay" minSdkVersion 14 targetSdkVersion 21 versionCode 1 versionName "1.0.0" &#125; // java版本 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7 &#125; buildTypes &#123; debug &#123; // debug模式 &#125; release &#123; // 是否进行混淆 minifyEnabled false // 混淆文件的位置 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125; // 移除lint检查的error lintOptions &#123; abortOnError false &#125;&#125;dependencies &#123; // 编译libs目录下的所有jar包 compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:support-v4:21.0.2' compile 'com.etsy.android.grid:library:1.0.5' compile 'com.alexvasilkov:foldable-layout:1.0.1' // 编译extras目录下的ShimmerAndroid模块 compile project(':extras:ShimmerAndroid')&#125; Roay/build.gradle 这个文件是整个项目的gradle基础配置文。 内容主要包含了两个方面：一个是声明仓库的源，这里可以看到是指明的jcenter(), 之前版本则是mavenCentral(), jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。另一个是声明了android gradle plugin的版本，android studio 1.0正式版必须要求支持gradle plugin 1.0的版本。 文件内容如下：1234567891011121314151617181920212223242526272829303132333435363738// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123;// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.0.0' &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; ​ ​]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android简易计分板实现]]></title>
    <url>%2Fpages%2F81bae912%2F</url>
    <content type="text"><![CDATA[一、View的选择 分析整个 APP 的组成： TextView： 4 个 Button： 7个 空白 View：1个 二、Layout布局 采用 RelativeLayout 作为整体布局父容器。 将其分为上下两个部分，下面部分只有一个 Button ，直接设置好其相对于父视图的位置参数以及自身属性即可。 上面部分又可以横向分为三个部分： 1.TeamA 团队的加分 Button 及显示的 TextView； 对于 TeamA， 其中各组件纵向排列，可采用Vertical LinearLayout作为其视图容器。 2.空白 View 做中间隔离； 3.TeamB 团队的加分 Button 及显示的 TextView 。 对于 TeamB，其设置等同于 TeamA 的设置。 可以采用 Horizontal LinearLayout 作为其视图容器。 整体布局 active_main.xml 代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#D2403E" android:padding="@dimen/activity_vertical_margin" tools:context="com.roojay.android.courtcounter.MainActivity"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="18dp" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView style="@style/textView" android:id="@+id/teama_text_view" android:text="@string/team_a" /&gt; &lt;TextView android:id="@+id/pointsa_text_view" style="@style/pointsTextView" android:text="@string/points_a" /&gt; &lt;Button style="@style/addButtonView" android:id="@+id/buttona3" android:onClick="addThreeA" android:text="@string/add3a" /&gt; &lt;Button style="@style/addButtonView" android:id="@+id/buttona2" android:onClick="addTwoA" android:text="@string/add2a" /&gt; &lt;Button style="@style/addButtonView" android:id="@+id/buttona1" android:onClick="addOneA" android:text="@string/add1a" /&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width="1dp" android:layout_height="match_parent" android:layout_marginTop="8dp" android:layout_marginBottom="8dp" android:background="#FFFEFE" /&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView style="@style/textView" android:id="@+id/teamb_text_view" android:text="@string/team_b" /&gt; &lt;TextView style="@style/pointsTextView" android:id="@+id/pointsb_text_view" android:text="@string/points_b" /&gt; &lt;Button style="@style/addButtonView" android:id="@+id/buttonb3" android:onClick="addThreeB" android:text="@string/add3b" /&gt; &lt;Button style="@style/addButtonView" android:id="@+id/buttonb2" android:onClick="addTwoB" android:text="@string/add2b" /&gt; &lt;Button style="@style/addButtonView" android:id="@+id/buttonb1" android:onClick="addOneB" android:text="@string/add1b" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;Button style="@style/resetButtonView" android:id="@+id/button_reset" android:onClick="reset" android:text="@string/reset_text_views" /&gt;&lt;/RelativeLayout&gt; 三、交互 通过 Button 的 android:onClick 属性指定方法。 将各个 Button 与 Java 中的方法关联起来。 具体操作是在 active_main.xml 中设置 android:onClick=”buttonName” 为每个 Button 设置一个独特的名字，这个名字用于 Java 代码寻找和识别每个不同的 Button 。 例如： 1在 active_main.xml 中设置 Button3A 的 onClick 属性为 android:onClick="addThreeA" 在 MainActivity.java 中编写代码： 12345public void addThreeA(View view) &#123;//所需要执行的操作，假如是 A 团队加三分&#125; 那么当你按下 Button3A 就将 A 团队的分数加上三分。 整个 MainActivity.java 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.roojay.android.courtcounter;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; int scorea = 0; int scoreb = 0; /** * Add 3 points for the Team A. */ public void addThreeA(View view) &#123; scorea = scorea + 3; displayTeamscorea(scorea); &#125; /** * Add 2 points for the Team A. */ public void addTwoA(View view) &#123; scorea = scorea + 2; displayTeamscorea(scorea); &#125; /** * Add 1 point for the Team A. */ public void addOneA(View view) &#123; scorea = scorea + 1; displayTeamscorea(scorea); &#125; /** * Displays the given scorea for Team A. */ public void displayTeamscorea(int scorea) &#123; TextView scoreaView = (TextView) findViewById(R.id.pointsa_text_view); scoreaView.setText(String.valueOf(scorea)); &#125; /** * Add 3 points for the Team B. */ public void addThreeB(View view) &#123; scoreb = scoreb + 3; displayTeamscoreb(scoreb); &#125; /** * Add 2 points for the Team B. */ public void addTwoB(View view) &#123; scoreb = scoreb + 2; displayTeamscoreb(scoreb); &#125; /** * Add 1 point for the Team B. */ public void addOneB(View view) &#123; scoreb = scoreb + 1; displayTeamscoreb(scoreb); &#125; /** * Displays the given scoreb for Team B. */ public void displayTeamscoreb(int scoreb) &#123; TextView scorebView = (TextView) findViewById(R.id.pointsb_text_view); scorebView.setText(String.valueOf(scoreb)); &#125; public void reset(View view) &#123; scorea = 0; scoreb = 0; displayTeamscorea(scorea); displayTeamscoreb(scoreb); &#125;&#125; 四、代码优化及 APP 美化style.xml 的设置 当每一个 View 都有着大量相同的元素，可以将这些元素定义在res/value/styles.xml 中。 具体的写法如下： 123456&lt;style name="cofe_textView"&gt; &lt;item name="android:textColor"&gt;#FFFFFF&lt;/item&gt; &lt;item name="android:layout_width"&gt;wrap_content&lt;/item&gt; ... &lt;/style&gt; 然后可以用style=&quot;@style/cofe_textView&quot;语句轻易地重复引用这些设置： 例如：1234&lt;TextView style="@style/textView" android:id="@+id/teamb_text_view" android:text="@string/team_b" /&gt; 整个 style.xml 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name="textView"&gt; &lt;item name="android:layout_width"&gt;match_parent&lt;/item&gt; &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; &lt;item name="android:fontFamily"&gt;sans-serif-medium&lt;/item&gt; &lt;item name="android:gravity"&gt;center&lt;/item&gt; &lt;item name="android:textColor"&gt;#FFFEFE&lt;/item&gt; &lt;item name="android:textSize"&gt;24sp&lt;/item&gt; &lt;/style&gt; &lt;style name="pointsTextView"&gt; &lt;item name="android:layout_width"&gt;match_parent&lt;/item&gt; &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; &lt;item name="android:fontFamily"&gt;sans-serif-medium&lt;/item&gt; &lt;item name="android:layout_margin"&gt;24dp&lt;/item&gt; &lt;item name="android:gravity"&gt;center&lt;/item&gt; &lt;item name="android:textColor"&gt;#2B2A2A&lt;/item&gt; &lt;item name="android:textSize"&gt;56sp&lt;/item&gt; &lt;item name="android:background"&gt;#FFFEFE&lt;/item&gt; &lt;/style&gt; &lt;style name="addButtonView"&gt; &lt;item name="android:layout_width"&gt;match_parent&lt;/item&gt; &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; &lt;item name="android:layout_marginBottom"&gt;8dp&lt;/item&gt; &lt;item name="android:layout_marginLeft"&gt;24dp&lt;/item&gt; &lt;item name="android:layout_marginRight"&gt;24dp&lt;/item&gt; &lt;item name="android:background"&gt;#2B2A2A&lt;/item&gt; &lt;item name="android:textColor"&gt;#FFFEFE&lt;/item&gt; &lt;/style&gt; &lt;style name="resetButtonView"&gt; &lt;item name="android:layout_width"&gt;wrap_content&lt;/item&gt; &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; &lt;item name="android:layout_marginBottom"&gt;32dp&lt;/item&gt; &lt;item name="android:background"&gt;#2B2A2A&lt;/item&gt; &lt;item name="android:textColor"&gt;#FFFEFE&lt;/item&gt; &lt;item name="android:layout_centerHorizontal"&gt;true&lt;/item&gt; &lt;item name="android:layout_alignParentBottom"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; strings.xml 在 Android 中会将应用中出现的文字放入 string.xml 中，这样一个字符可以重复调用，而不用每次去编写，可以减少数据的冗余，减小 APP 应用的体积。并且当你的 APP 国际化时只需更改 strings.xml 中的文字定义，就可以实现其他语言的显示。 strings.xml 中的字符定义如下：1234&lt;resources&gt; &lt;string name="text_name"&gt;显示的文字&lt;/string&gt; ...&lt;/resources&gt; 调用时：1android:text="@string/text_name" 整个 strings.xml 代码如下1234567891011121314&lt;resources&gt; &lt;string name="app_name"&gt;Court Counter&lt;/string&gt; &lt;string name="add2b"&gt;+2 points&lt;/string&gt; &lt;string name="add1b"&gt;+1 pointsb&lt;/string&gt; &lt;string name="team_a"&gt;Team A&lt;/string&gt; &lt;string name="add2a"&gt;+2 points&lt;/string&gt; &lt;string name="points_a"&gt;0&lt;/string&gt; &lt;string name="add3a"&gt;+3 points&lt;/string&gt; &lt;string name="add1a"&gt;+1 points&lt;/string&gt; &lt;string name="team_b"&gt;Team B&lt;/string&gt; &lt;string name="points_b"&gt;0&lt;/string&gt; &lt;string name="add3b"&gt;+3 points&lt;/string&gt; &lt;string name="reset_text_views"&gt;reset&lt;/string&gt;&lt;/resources&gt; 五、APP 强制锁定横竖屏 在最开始做出 APP 时没有考虑到 APP 横屏的问题，偶然一次横屏之后发现 APP 显示不全了，当时也没多想，既然横屏不行，那就去掉横屏显示，锁定在竖屏。上网查了下资料，锁定横竖屏有两种实现方式：XML 或 Java 方式。这个 APP 采用了 XML 锁定方式。 XML锁定横屏或竖屏 在AndroidManifest.xml中配置,在Activity标签中加入android:screenOrientation=”unspecified”，来使某个Activity做横竖屏的变化。 使用android:screenOrientation=”unspecified”来锁定横竖屏。 unspecified：未指明屏幕方向。 landscape：锁定为横屏。 portrait：锁定为竖屏。 具体代码如下：123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.roojay.android.courtcounter"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme" &gt; &lt;activity android:name=".MainActivity" android:screenOrientation="portrait"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; Java代码锁定横竖屏 在onCreate()方法中加入锁定代码。 代码如下：123456789public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);//锁定为横屏 //setRequestedOrientation(ActivityInfo .SCREEN_ORIENTATION_PORTRAIT);//锁定为竖屏 setContentView(R.layout.activity_main); &#125; 六、APP 演示及源码 APP 的最终效果图，没有进行多余的其他手机测试，也不知道其他手机显示效果是不是这样。 演示视频：http://omjmn55ir.bkt.clouddn.com/%E7%AF%AE%E7%90%83%E8%AE%A1%E5%88%86%E6%9D%BF%E6%BC%94%E7%A4%BAmp4 源码：https://github.com/roojay520/CourtCounter]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础与Button交互]]></title>
    <url>%2Fpages%2Fb8bb4b60%2F</url>
    <content type="text"><![CDATA[变量的定义 在程序的运行过程中，会产生一些临时数据储存在内存单元中，这每一个内存单元都用一个标识符来标识，这些内存单元被称为变量。 变量的数据类型变量的数据类型分为两种，即基本数据类型和引用数据类型。 1. 基本数据类型 数值型分为两种： 1.1 整数类型（byte 1字节，short 2字节，int 4字节，long 8字节） 1.2 浮点类型（float 4字节，double 8字节） 字符型（char）2字节 布尔型（boolean）1字节2. 引用数据类型 类（class) 接口（interface） 数组 枚举（enum） 注解（annotation）变量类型转换在程序中，当把一种数据类型的值赋值给另一种数据类型时，需要进行数据类型的转换。数据类型转换分为两种：自动类型转换和强制类型转换。1. 自动类型转换两种数据类型转换不需要显式声明，自动转换类型必须满足两个条件：两种数据类型彼此兼容和转换目标类型的取值范围必须大于原来类型的取值范围。 byte→short，int，long short，char→int，long int→long byte，char，short，int→float byte，char，short，int，long，float→double boolean类型无法转换为其他类型。2. 强制类型转换自动转换类型无法进行转换时，进行强制类型转换。取值范围较大的数据类型转换为取值范围较小的类型，可能会造成精度丢失。 例如：12int num;byte b =(byte)num; 常量 在编程语言中，常量是指在整个程序中永远不会改变的值。在 Java 中，你可以使用关键字 final 来强制规定某个值不得被更改。例如：1final int POINTS_FOR_FREE_THROW = 1; Then if you wrote the following, you’d get an error:1POINTS_FOR_FREE_THROW = 100; 注意，按照惯例，常量的名称全为大写形式。此外，单词之间用下划线连接，而不用空格或用骆驼拼写法。你可以将变量声明为常量，防止自己意外地更改了变量的值。方法 为解决代码重复编写的问题所设计的特定功能代码块。方法不能嵌套。main（）方法的作用：调用方法的实例化对象。 方法结构一般为：123456修饰符 返回值类型 方法名（参数类型 参数1，参数类型 参数2，...）&#123; 执行语句 ... ... return 返回值； &#125; 选择结构语句if条件语句 当判断条件1结果为 true 时，执行语句 1，为 false 时，执行语句 2。当判断条件 1, 2 都不满足 true 时，执行语句 3。 例如：123456789if (判断条件1)&#123; 执行语句1&#125;else if(判断条件2)&#123; 执行语句2&#125;else&#123; 执行语句3&#125; 三元运算 一种类似于 if-else 语句的运算，三元运算一般会得到一个结果，一般用来对某个变量进行赋值。当判断条件成立时结果为表达式1的值，否则表达式2的值。1判断条件 ? 表达式 1 : 表达式 2 例如：求取两个数 x，y 中较大的值。123456789101112//if-else 实现方法int x, y, max;if(x&gt;y)&#123; max = x;&#125;else&#123; max = y;&#125;//三元运算实现int x, y, max;max = x &gt; y ? x : y; switch语句 在 switch 语句中使用 switch 关键字来描述一个表达式，使用case关键字来描述和表达式结果比较的目标值，当表达式的值和某个目标值匹配时，会执行对应 case 下的语句。 例如：1234567891011121314switch(表达式)&#123; case 1: 执行语句1; break; //break终止case并跳出switch循环 case 2: 执行语句2; break; case 3: 执行语句3； break; default: //default处理和前面的case都不匹配的值 执行语句4; break; &#125; 循环结构语句while 循环语句 循环条件判断为 true 时，执行语句循环执行，直到循环条件为 false。 例如：123while(循环条件)&#123; 执行语句&#125; do…while循环语句 循环体会无条件执行一次，然后根据循环条件决定是否继续执行。 例如：1234do&#123; 执行语句&#125;while(循环条件); for循环语句 一般用在循环次数已知的情况下，循环条件 ② 判断为 true 时，执行顺序为： ①→②→④→③，初始化表达式 ① 只在第一次循环时执行。 例如：123for(初始化表达式①;循环条件②;操作表达式③)&#123; 执行语句④&#125; 1234567891011121314151617181920/*** Created by Roojay on 2017/4/7.* 利用嵌套循环打印一个正三角形。*/public class Test1 &#123; public static void main(String args[])&#123; int i, j, k; for(i = 1; i &lt;= 5; i++)&#123; for(k = 0; k &lt; 5 - i; k++)&#123; System.out.print(" "); &#125; for(j = 1; j &lt;= i; j++)&#123; System.out.print("* "); &#125; System.out.println(); &#125; &#125;&#125; 跳转语句break语句 当它出现在 switch 条件语句中时，作用是终止某个 case 并跳出 switch 结构。当它出现在循环语句中，作用是跳出循环语句，执行后面的代码。当它出现在嵌套循环内层循环中时，只能跳出内层循环，如果想跳出外层循环，需要对外层前面添加标记 itcast： ，在后面使用 break itcast 跳出外层循环。 continue语句continue 语句用在循环语句中，它的作用是终止本次循环，执行下一次循环。也可以使用标记结束外循环。 Button交互 XML 布局文件中的 元素创建 Button，则可以使用该元素的 android:onClick 属性指定方法。这一方便的备选方案专为不改变行为的 Button 提供。 android:onClick=”buttonName”屏幕输出显示MainActivity.java部分123456789public void display(String text) &#123; TextView t = (TextView) findViewById(R.id.display_text_view); t.setText(text);&#125;public void display(int text) &#123; TextView t = (TextView) findViewById(R.id.display_text_view); t.setText(text + "");&#125; 其中 R.id.display_text_view中的display_text_view是指具体输出显示的TextView的ID。 activity_main.xml部分1234567&lt;TextView android:id="@+id/display_text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="" android:textSize="45sp" android:textColor="#000000"/&gt; Style 下面两个 TextView 都设置着大量相同的元素： 123456789101112131415161718192021222324252627&lt;TextView android:id="@+id/tell" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_above="@id/adress" android:text="电话:028-666666" android:textSize="24sp" android:textColor="#FFFFFF" android:background="#795548" android:layout_marginLeft="8dp" android:layout_marginTop="8dp" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_above="@id/tell" android:text="半岛咖啡" android:textSize="30sp" android:textColor="#FFFFFF" android:background="#795548" android:layout_marginLeft="8dp" /&gt;&lt;!-- 相同的元素 --&gt;&lt;TextView android:textColor="#FFFFFF" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="#795548" android:layout_marginLeft="8dp" /&gt; 可以在res/value/styles.xml里定义个 style 来包括这些通用的元素设置： 1234567&lt;style name="cofe_textView"&gt; &lt;item name="android:textColor"&gt;#FFFFFF&lt;/item&gt; &lt;item name="android:layout_width"&gt;wrap_content&lt;/item&gt; &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; &lt;item name="android:background"&gt;#795548&lt;/item&gt; &lt;item name="android:layout_marginLeft"&gt;8dp&lt;/item&gt; &lt;/style&gt; 然后可以用以下一句语句轻易地重复引用这些设置：1style="@style/cofe_textView" 这一段 TextView 可以重构为以下： 12345678910111213&lt;TextView style="@style/cofe_textView" android:id="@+id/tell" android:layout_above="@id/adress" android:text="电话:028-666666" android:textSize="24sp" android:layout_marginTop="8dp" /&gt;&lt;TextView style="@style/cofe_textView" android:layout_above="@id/tell" android:text="半岛咖啡" android:textSize="30sp" /&gt;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View&Layout]]></title>
    <url>%2Fpages%2F29c8a334%2F</url>
    <content type="text"><![CDATA[View 视图TextView 字体大小属性：android:textSize=”36sp” 或者采用另一种字体大小定义方式： android:textAppearance=”?android:textAppearanceLarge” As of API 19 (KitKat): ?android:textAppearanceSmall is currently 14sp ?android:textAppearanceMedium is currently 18sp ?android:textAppearanceLarge is currently 22sp 文字颜色属性：android:textColor 文本变成大写：android:textAllCaps=”true” 字体属性：android:textStyle=”bold” bold:粗体；italic:斜体；bolditalic:粗斜体。 属性：android:fontFamily=”sans-serif-light” 字体设置。 属性值 wrap_conent:自适应大小。 gravity中文意思是”重心“，就是表示view横向和纵向的停靠位置 android:gravity：是对view控件本身来说的，是用来设置view本身的内容应该显示在view的什么位置，默认值是左侧。也可以用来设置布局中的控件位置 android:layout_gravity：是相对于包含该元素的父元素来说的，设置该元素在父元素的什么位置； 比如TextView: android:layout_gravity表示TextView在界面上的位置，android:gravity表示TextView文本在TextView的什么位置，默认值是左侧. ​ 1234567&lt;TextView android:text="Hello Android!" android:background="@android:color/darker_gray" android:layout_width="150dp" android:layout_height="75dp" /&gt;&lt;!-- 注释内容 --&gt; ImageView 属性: android:scaleType=”center”:不改变图片大小居中显示。 属性: android:scaleType=”centerCrop”:自适应屏幕居中显示。 123456&lt;ImageView android:src="@drawable/cake" android:layout_width="wrap_content" android:layout_height="wrap_content" android:scaleType="center" /&gt; Button XML 布局文件中的 元素创建 Button，则可以使用该元素的 android:onClick 属性指定方法。这一方便的备选方案专为不改变行为的 Button 提供。 android:onClick=”buttonname” Layout 布局LinearLayout线性布局 View水平or垂直方向排列。 属性：android:orientation=”vertical” 决定布局以垂直(列)显示。 属性：android:orientation=”horizontal”决定布局以水平(行)显示。 1234567891011121314151617&lt;LinearLayoutandroid:layout_width="match_parent"android:layout_height="wrap_content"android:orientation="vertical"&gt;&lt;TextViewandroid:layout_width="match_parent"android:layout_height="wrap_content"android:text="1"/&gt;&lt;TextViewandroid:layout_width="match_parent"android:layout_height="wrap_content"android:text="2"/&gt;&lt;TextViewandroid:layout_width="match_parent"android:layout_height="wrap_content"android:text="3"/&gt;&lt;/LinearLayout&gt; Layout Weight layout_weight:视图权重。 vertical(垂直)时设置layout_height为0，设置layout_weight为1. horizontal(水平)时设置layout_width为0，设置layout_weight为1. RelativeLayout相对布局相对于父视图边缘位置对齐 上边缘对齐：android:layout_alignParentTop=”true” 下边缘对齐：android:layout_alignParentBottom=”true” 左边缘对齐：android:layout_alignParentLeft=”true” 右边缘对齐：android:layout_alignParentRight=”true” 垂直方向居中：android:layout_centerVertical=”true” 水平方向居中：android:layout_centerHorizontal=”true” 屏幕居中：android:layout_centerInParent=”true” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;RelativeLayoutandroid:layout_width="match_parent"android:layout_height="match_parent"&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentTop="true"android:layout_alignParentLeft="true"android:text="1"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentTop="true"android:layout_centerHorizontal="true"android:text="2"/&gt; &lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentTop="true"android:layout_alignParentRight="true"android:text="3"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_centerVertical="true"android:layout_alignParentLeft="true"android:text="4"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_centerInParent="true"android:text="Center"/&gt; &lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_centerVertical="true"android:layout_alignParentRight="true"android:text="5"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentBottom="true"android:layout_alignParentLeft="true"android:text="6"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentBottom="true"android:layout_centerHorizontal="true"android:text="7"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_alignParentBottom="true"android:layout_alignParentRight="true"android:text="8"/&gt;&lt;/RelativeLayout&gt; ​ 相对于其它视图定位 android:id=”@+id/viewname_text_view” 符号“@”表示Android应用中的资源。 位于center上边：android:layout_above=”@id/center” 位于center下边：android:layout_below=”@id/center” 位于center左边：android:layout_toLeftOf=”@id/center” 位于center右边：android:layout_toRightOf=”@id/center” 12345678910111213141516171819202122232425262728293031323334&lt;RelativeLayoutandroid:layout_width="match_parent"android:layout_height="match_parent"&gt;&lt;TextViewandroid:id="@+id/center"android:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_centerInParent="true"android:text="Center"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_toLeftOf="@id/center"android:layout_alignBottom="@id/center"android:text="2"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_toRightOf="@id/center"android:layout_alignBottom="@id/center"android:text="3"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_above="@id/center"android:layout_alignLeft="@id/center"android:text="1"/&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_below="@id/center"android:layout_alignLeft="@id/center"android:text="4"/&gt;&lt;/RelativeLayout&gt; 内边剧和外边距内边距(padding) android:padding=”8dp” OR android:paddingLeft=”8dp” android:paddingRight=”8dp” android:paddingTop=”8dp” android:paddingBottom=”8dp” 默认值为0 外边距(magin) android:layout_margin=”8dp” OR android:layout_marginLeft=”8dp” android:layout_marginRight=”8dp” android:layout_marginTop=”8dp” android:layout_marginBottom=”8dp” 默认值为0 创建视图 选择Views ； 摆放Views； 设计Views样式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2Fpages%2F9bc01b38%2F</url>
    <content type="text"><![CDATA[内部类：一个类定义在另一个类的里面。 示例：&gt;1234class A&#123; class B&#123; &#125;&#125; B这个类被称之为A的内部类。编译之后生成A.class和A$B.class。内部类可以随意使用外部类的成员变量。 内部类的使用方法示例：1234567891011121314151617181920212223class A&#123; int i; class B&#123; int j; int funB()&#123; int result = i + j; System.out.println(result); return result; &#125; &#125;&#125;class Test&#123; public static void main(String args[])&#123; A a = new A(); A.B b = a.new B(); a.i = 5; b.j = 6; b.funB(); &#125;&#125; 匿名内部类的使用方法 匿名内部类：没有名字的内部类。 示例：12345678910111213141516171819interface A&#123; public void doSth();&#125;class B&#123; public void fun(A a)&#123; System.out.println("B类的fun函数"); a.doSth(); &#125;&#125;public class Test&#123; public static void main(String args[])&#123; B b = new B(); b.fun(new A()&#123; public void doSth()&#123; System.out.println("匿名内部类"); &#125; &#125;); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的异常]]></title>
    <url>%2Fpages%2Ff029d2bb%2F</url>
    <content type="text"><![CDATA[什么是异常 异常的分类 try…catch…finally结构的使用方法 1. 什么是异常？ 异常(Exception)：中断了正常指令流的事件。 异常是一个对象； 异常产生于程序运行时； 指令流：程序执行时一系列的连续指令称为指令流。 示例：12345class Test&#123; public static void main(String args[])&#123; int i = 1 / 0; &#125;&#125; 抛出异常： Exception in thread “main” java.lang.ArithmeticException: / by zero at Test3.main(Test3.java:6) Exception in thread “main” ：在主线程中出现异常； ArithmeticException：异常的名称，算术异常； / by zero：被0除； at Test.main(Test.java:3)：异常位置； 2. 异常的分类JDK提供的类： Throwable：所有异常的父类； Error：虚拟机运行时产生的错误，产生错误，虚拟机直接关闭； Exception： 分为UncheckExeption（RuntimeExeption）和CheckExeption RuntimeException + Error 和其子类都是属于uncheckexceptionException类中除了 RuntimeException之外的类，都是属于checkexception ExceptioncheckException checkException是必须要处理的，也就是不能抛出，必须通过try-catch来完成，不处理的话是不能进行编译的。示例：123456class TestCheck&#123; public static void main(String args[])&#123; //CheckException Thread.sleep(1000); //让当前线程休眠1000ms &#125;&#125; 运行结果： uncheckException（ RuntimeException） 运行时异常包括平常遇到的各种异常，如空指针异常，数据格式异常等一系列异常，这种异常是可以不捕获的，可通过throws抛出异常，交给别的代码或者JAVA虚拟机来完成示例：123456class Test&#123; public static void main(String args[])&#123; //UncheckException int i = 1 / 0; &#125;&#125; 运行结果： 3. try…catch…finally结构 12345678910111213try&#123; //代码A //有可能出现异常的代码B //代码C&#125;catch(Exception e)&#123; //虚拟机产生的异常对象e e.printStackTrace(); //处理异常的代码D //代码E&#125;finally&#123; //异常的出口 //执行扫尾工作的代码F&#125; 如果try中代码B没有异常：执行代码A-B-C-F如果try中代码B出现异常：执行代码A-B-D-E-FuncheckException 1234567891011121314151617181920//uncheckExceptionclass TestCheck&#123; public static void main(String args[])&#123; System.out.println(1); try&#123; System.out.println(2); //有可能出现异常的代码 int i = 1/0; System.out.println(3); &#125; catch(Exception e)&#123; //虚拟机产生的异常对象e e.printStackTrace(); //打印异常栈的追踪信息 System.out.println(4); &#125; finally&#123; //异常的出口 System.out.println("finally"); &#125; &#125;&#125; 运行结果： checkException 1234567891011121314151617181920//checkExceptionclass TestCheck&#123; public static void main(String args[])&#123; System.out.println(1); try&#123; System.out.println(2); //有可能出现异常的代码 Thread.sleep(1000); //让当前线程休眠1000ms System.out.println(3); &#125; catch(Exception e)&#123; //虚拟机产生的异常对象e e.printStackTrace(); //打印异常栈的追踪信息 System.out.println(4); &#125; finally&#123; //异常的出口 System.out.println("finally"); &#125; &#125;&#125; 运行结果：屏幕首先显示1，2，然后停顿1000ms，再显示3和finally]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多线程]]></title>
    <url>%2Fpages%2F265f6f6b%2F</url>
    <content type="text"><![CDATA[多进程在操作系统中能（同时）运行多个任务（程序）。 多线程在同一应用程序中有多个顺序流（同时）执行。 线程的创建方法继承Thread类创建多线程 继承Thread类，覆写Thread类的run（）方法，在run（）方法中实现运行在线程上的代码。 定义一个类FirstThread继承Thread类，覆写Thread类的run（）方法； 生成线程类的对象firstThread； 启动线程start（）方法。 示例：12345678910111213141516171819202122public class Test&#123; public static void main(String args[])&#123; //生成线程类的对象 FirstThread firstThread = new FirstThread(); //启动线程start（）方法 firstThread.start(); for(int i = 1; i &lt; 50; i++)&#123; System.out.println("Main----&gt;:" + i); &#125; &#125;&#125;//继承Thread类，覆写Thread类的run（）方法class FirstThread extends Thread&#123; public void run()&#123; for(int i = 1; i &lt; 50; i++)&#123; System.out.println("FirstThread---&gt;:" + i); &#125; &#125;&#125; 实现Runnable接口创建多线程 提供一个实现接口Runnable的类作为线程的目标对象，在初始化一个Thread类或者Thread子类的线程对象时，把目标对象传递给这个线程实例，由该目标对象提供线程体。 定义一个类FirstThread实现Runnable接口； 生成Runnable实现类FirstThread的一个对象firstThread； 生成一个Thread对象，并将firstThread作为参数传递给该Thread对象； 通知Thread对象执行start（）方法。 示例：123456789101112131415161718192021222324public class Test&#123; public static void main(String args[])&#123; //生成Runnable实现类FirstThread的一个对象firstThread FirstThread firstThread = new FirstThread(); //生成一个Thread对象 //并将firstThread作为参数传递给该Thread对象 Thread thread = new Thread(firstThread); //通知Thread对象执行start（）方法 thread.start(); for(int i = 1; i &lt;50; i++)&#123; System.out.println("Main---&gt;:" + i); &#125; &#125;&#125;//实现Runnable接口的类FirstThreadclass FirstThread implements Runnable&#123; public void run()&#123; for(int i = 1; i &lt;50; i++)&#123; System.out.println("FirstThread---&gt;:" + i); &#125; &#125;&#125; 线程的简单控制方法 中断线程 Thread.sleep（n毫秒）//当前线程休眠n毫秒 Thread.yield（）//当前线程自动让出CPU，AB重新线程抢占CPU 设置线程的优先级 getPriority（） setPriority（） thread.setPriority(Thread.MAX_PRIORITY) //设置最大优先级为10 thread.setPriority(Thread.MIN_PRIORITY) //设置最小优先级为1 同步语法同步代码块1234synchronized(this) &#123; //this：同步锁 代码块&#125; synchronized锁住一个对象。 如果线程A得到同步锁，那么他将可以执行代码块， 即使线程B从线程A手中抢到了同步锁，B也不能立即执行代码块，它必须等到线程A执行完这个代码块之后才能执行。 示例1234567891011121314151617181920212223242526272829303132public class Test&#123; public static void main(String args[])&#123; MyThread myThread = new MyThread(); //生成两个Thread对象，但是这两个Thread对象共用同一个线程体 Thread t1 = new Thread(myThread); Thread t2 = new Thread(myThread); //通过Thread对象的setName（）方法设置线程名字 //使用getName方法获取线程的名字 t1.setName("线程A"); t2.setName("线程B"); //分别启动两个线程 t1.start(); t2.start(); &#125;&#125;class MyThread implements Runnable&#123; int i = 100; public void run()&#123; while(true)&#123; synchronized(this)&#123; //this：同步锁 //Thread.currentThread()获取当前这段代码运行的线程位置 System.out.println(Thread.currentThread().getName() + i); i--; Thread.yield(); if(i &lt; 0)&#123; break; &#125; &#125; &#125; &#125;&#125; 同步方法1234public synchronized void run()&#123; 代码块&#125; synchronized锁住this。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[throw和throws]]></title>
    <url>%2Fpages%2F29cc0096%2F</url>
    <content type="text"><![CDATA[throwthrow的作用 如果Java虚拟机不能判断异常e，可以生成异常对象e，用throw加上这个异常对象抛出这个异常。 示例： 123456789101112131415161718package src;class People&#123; private int age; public void setAge(int age)&#123; if(age &lt; 0)&#123; RuntimeException e = new RuntimeException("年龄不能为负数"); throw e; &#125; this.age = age; System.out.println(age); &#125;&#125;class Test&#123; public static void main(String args[])&#123; People people = new People(); people.setAge(-20); &#125;&#125; 运行结果： throwsthrows 声明一个函数可能产生异常，函数不对异常进行处理，在调用函数的地方对异常进行处理。 示例： 1234567891011121314151617181920212223package src1;class People&#123; private int age; public void setAge(int age) throws Exception&#123; if(age &lt; 0)&#123; Exception e = new Exception("年龄不能为负数"); throw e; &#125; this.age = age; System.out.println(age); &#125;&#125;class Test&#123; public static void main(String args[])&#123; People people = new People(); try&#123; people.setAge(-20); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; 运行结果：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的数组]]></title>
    <url>%2Fpages%2Fe7882660%2F</url>
    <content type="text"><![CDATA[数组是用来存储固定大小的同类型元素。 数组的定义方法静态定义法1int arr [] = &#123;1,5,6,4,&#125;; arr：整型数组。 arr[n]：n为下标，从第0位开始。arr[0]=1, arr[1]=5, arr[2]=6. 数组长度：arr.length. 动态定义法1int arr [] = new int[10]; 数组的长度为10. 二维数组的定义方法123456静态定义法：int arr[] [] = &#123;&#123;5,3,6&#125;,&#123;5,8,7&#125;,&#123;6,3,2&#125;&#125;;动态定义法：int arr[] [] = new int[][];例：int[1][2] = 7;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的变量]]></title>
    <url>%2Fpages%2Fc075d141%2F</url>
    <content type="text"><![CDATA[变量的定义 在程序的运行过程中，会产生一些临时数据储存在内存单元中，这每一个内存单元都用一个标识符来标识，这些内存单元被称为变量。 变量的数据类型变量的数据类型分为两种，即基本数据类型和引用数据类型。 1. 基本数据类型 数值型分为两种： 1.1 整数类型（byte 1字节，short 2字节，int 4字节，long 8字节） 1.2 浮点类型（float 4字节，double 8字节） 字符型（char）2字节 布尔型（boolean）1字节 2. 引用数据类型 类（class) 接口（interface） 数组 枚举（enum） 注解（annotation） 变量类型转换 在程序中，当把一种数据类型的值赋值给另一种数据类型时，需要进行数据类型的转换。数据类型转换分为两种：自动类型转换和强制类型转换。 1. 自动类型转换 两种数据类型转换不需要显式声明，自动转换类型必须满足两个条件：两种数据类型彼此兼容和转换目标类型的取值范围必须大于原来类型的取值范围。 byte→short，int，long short，char→int，long int→long byte，char，short，int→float byte，char，short，int，long，float→double boolean类型无法转换为其他类型。 2. 强制类型转换 自动转换类型无法进行转换时，进行强制类型转换。取值范围较大的数据类型转换为取值范围较小的类型，可能会造成精度丢失。 例如：12int num;byte b =(byte)num;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的I/O流]]></title>
    <url>%2Fpages%2F649b2029%2F</url>
    <content type="text"><![CDATA[流的概念和作用&gt; 流是数据源到Java程序，Java程序到输出位置之间的管道。 IO流的分类 根据数据处理类的不同分为：字符流和字节流。 根据数据流向不同分为：输入流和输出流。 输入输出是以Java程序为参照物的，相对于Java程序本身 输入流：从数据源中读取数据到Java程序中，这个过程称之为输入。 输出流：Java程序将数据写入到其他地方，这个过程称之为输出。 节点流和处理流。 节点流：普通的管道； 处理流：功能性管道，对数据进一步加工。 字节流字节流中的核心类 InputStream int read(byte [] b,int off,int len)byte[] b：byte类型数组；int off：偏移量；int len： 读取数据的量；返回值为这次调用read方法读取数据的长度。 OutputStream void write(byte [] b,int off,int len)byte[] b：byte类型数组；int off：偏移量；int len： 写入数据的量； 程序步骤 导入类 java.io.*； 定义主函数； 声明输入流的引用； 声明输出流的引用；123456789101112131415161718192021try&#123; 1.生成代表输入流的对象； 2.生成代表输出流的对象； 3. 生成一个byte字节数组； 4.调用输入流的read方法读取数据； 5.定义临时变量接受数据的量； 6.调用输出流的write方法写入数据；&#125;catch(Exception e)&#123; Systen.out.println(e);&#125;//finally进行结尾处理finally&#123; try&#123; fis.close(); fos.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125;&#125; 示例 1：12345678910111213141516171819202122232425262728293031323334import java.io.*;public class Test&#123; public static void main(String args[])&#123; //声明输入流引用 FileInputStream fis = null; //声明输出流引用 FileOutputStream fos = null; try&#123; //生成代表输入流的对象 fis = new FileInputStream("D:/java/8.8/from.txt"); //生成代表输入流的对象 fos = new FileOutputStream("D:/java/8.8/to.txt"); //生成一个字节型buffer数组 byte[] buffer = new byte[100]; //定义一个临时变量，用于接受调用输入流read方法读取数据的量 int temp = fis.read(buffer,0,b.length); //调用输出流的write方法写入数据 fos.write(buffer,0,temp); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125; //finally进行结尾处理 finally&#123; try&#123; fis.close(); fos.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; 大文件的读写 调节buffer数组的大小； 对read，write方法采取while循环； 示例 2：1234567while(true)&#123; int temp = fis.read(buffer,0,buffer.length); if(temp == -1)&#123; break; &#125; fos.write(buffer,0,temp);&#125; 字符流 字符流：是以对写文件时，以字符为基础 字节输入流：Reader &lt;–FileReader int read(char [] c, int off, int length ) 字节输出流：Writer &lt;–FileWriter void writer(char [] c, int off, int length) 示例 3：12345678910111213141516171819202122232425262728293031import java.io.*;public class TestChar&#123; public static void main(String args[])&#123; FileReader fr = null; FileWriter fw = null; try&#123; fr = new FileReader("d:/java/9.5/read.txt"); fw = new FileWriter("d:/java/9.5/write.txt"); char [] buffer = new char[1024]; while(true)&#123; int temp = fr.read(buffer, 0, buffer.length); if(temp == -1)&#123; break; &#125; fw.write(buffer, 0, temp); &#125; &#125; catch(Exception e)&#123; System.out.println(e); &#125; finally&#123; try&#123; fr.close(); fw.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2Fpages%2F7dc91154%2F</url>
    <content type="text"><![CDATA[十进制转换二进制 将一个十进制数转换为二进制，就是将这个数不断取余的过程，将这个数除以 2，得到了商和余数，然后将商不断除以 2，直到商为 0，然后将余数倒过来排列，所得到的数就是转换的二进制结果。 二进制转八进制将二进制数自右向左每三位分成一段，然后将每三位数转换为一位八进制数。 例如：111000101 = 111 000 101 = 0 7 0 5 八进制以 0 开头。 二进制转十六进制 将二进制数自右向左每四位分成一段，然后将每四位转换为一位十六进制数。 例如：111010100110=1110 1010 0110=0x E A 6 十六进制以 0x 或者 0X 开头。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的运算符]]></title>
    <url>%2Fpages%2F83e4d5ed%2F</url>
    <content type="text"><![CDATA[Java中的运算符 Java中的运算符分为算术运算符，赋值运算符，比较运算符，逻辑运算符，位运算符。 算术运算符 进行除法运算时，如果除数和被除数都为整得到的结果也会是整数，会忽略小数部分。例如：16600/1000*1000 最后得到的结果为6000。表达式自左至右运算，6600/1000得到6，6*1000=6000。 进行除法运算时如果有小数参与，得到的结果为小数。例如：16.6/10 结果为0.66。 进行取模（%）运算时，运算结果的正负取决于%左边的（被模数）符号有关，与%右边的（模数）的符号无关。例如：1(-6)/2 结果为-3。16/(-3) 结果为2。 赋值运算符 可以通过一条赋值语句对多个变量进行赋值。例如： 12int x, y, z;x = y = z = 5; //为三个变量同时赋值。 使用+=、-=、*=、/=、%=进行赋值时，强制转换类型会自动完成。 位运算符左移：&lt;&lt; 00000100&lt;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法]]></title>
    <url>%2Fpages%2Fad01bc3e%2F</url>
    <content type="text"><![CDATA[为解决代码重复编写的问题所设计的特定功能代码块。方法不能嵌套。main（）方法的作用：调用方法的实例化对象。 方法结构一般为：123456修饰符 返回值类型 方法名（参数类型 参数1，参数类型 参数2，...）&#123; 执行语句 ... ... return 返回值； &#125; 方法的重载 Java 允许在一个程序中定义多个名称相同的方法]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构语句]]></title>
    <url>%2Fpages%2F1c7ee7be%2F</url>
    <content type="text"><![CDATA[选择结构语句if条件语句 当判断条件1结果为true时，执行语句1，为false时，执行语句2。当判断条件1,2都不满足true时，执行语句3。 例如：123456789if (判断条件1)&#123; 执行语句1&#125;else if(判断条件2)&#123; 执行语句2&#125;else&#123; 执行语句3&#125; 三元运算 一种类似于if-else语句的运算，三元运算一般会得到一个结果，一般用来对某个变量进行赋值。当判断条件成立时结果为表达式1的值，否则表达式2的值。1判断条件 ? 表达式 1 : 表达式 2 例如：求取两个数x，y中较大的值。123456789101112//if-else实现方法int x, y, max;if(x&gt;y)&#123; max = x;&#125;else&#123; max = y;&#125;//三元运算实现int x, y, max;max = x &gt; y ? x : y; switch语句 在switch语句中使用switch关键字来描述一个表达式，使用case关键字来描述和表达式结果比较的目标值，当表达式的值和某个目标值匹配时，会执行对应case下的语句。 例如：1234567891011121314switch(表达式)&#123; case 1: 执行语句1; break; //break终止case并跳出switch循环 case 2: 执行语句2; break; case 3: 执行语句3； break; default: //default处理和前面的case都不匹配的值 执行语句4; break; &#125; 循环结构语句while循环语句 循环条件判断为true时，执行语句循环执行，直到循环条件为false。 例如：123while(循环条件)&#123; 执行语句&#125; do…while循环语句 循环体会无条件执行一次，然后根据循环条件决定是否继续执行。 例如：1234do&#123; 执行语句&#125;while(循环条件); for循环语句 一般用在循环次数已知的情况下，循环条件判断为true执行顺序①→②→④→③ 例如：123for(初始化表达式①;循环条件②;操作表达式③)&#123; 执行语句④&#125; 1234567891011121314151617181920/** * Created by Roojay on 2017/4/7. * 利用嵌套循环打印一个正三角形。 */public class Test1 &#123; public static void main(String args[])&#123; int i, j, k; for(i = 1; i &lt;= 5; i++)&#123; for(k = 0; k &lt; 5 - i; k++)&#123; System.out.print(" "); &#125; for(j = 1; j &lt;= i; j++)&#123; System.out.print("* "); &#125; System.out.println(); &#125; &#125;&#125; 跳转语句break语句 当它出现在switch条件语句中时，作用是终止某个case并跳出switch结构。当它出现在循环语句中，作用是跳出循环语句，执行后面的代码。当它出现在嵌套循环内层循环中时，只能跳出内层循环，如果想跳出外层循环，需要对外层前面添加标记 itcast： ，在后面使用 break itcast 跳出外层循环。 continue语句 continue语句用在循环语句中，它的作用是终止本次循环，执行下一次循环。也可以使用标记结束外循环。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理流Decorator模式]]></title>
    <url>%2Fpages%2Fbbf344f6%2F</url>
    <content type="text"><![CDATA[处理流BufferedReader readeLine：每次读取一行数据 示例：1234567891011121314151617181920212223242526272829303132import java.io.*;public class Test&#123; public static void main(String args[])&#123; FileReader filereader = null; BufferedReader bufferedreader = null; try&#123; filereader = new FileReader("C:/Users/Jay/Desktop/9.6/src1/read.txt"); bufferedreader = new BufferedReader(filereader); String line = null; while(true)&#123; line = bufferedreader.readLine(); if(line == null)&#123; break; &#125; System.out.println(line); &#125; &#125; catch(Exception e)&#123; System.out.println(e); &#125; finally&#123; try&#123; filereader.close(); bufferedreader.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125; &#125;&#125; Decorator（装饰者）模式 示例：123456789101112131415161718192021222324252627282930313233343536373839interface Teacher&#123; public void teaching();&#125;class MathTeacher implements Teacher&#123; public void teaching()&#123; System.out.println("我是一名数学老师"); &#125;&#125;class ChineseTeacher implements Teacher&#123; public void teaching()&#123; System.out.println("我是一名语文老师"); &#125;&#125;class ATeacher implements Teacher&#123; private Teacher teacher; public ATeacher(Teacher teacher)&#123; this.teacher = teacher; &#125; public void teaching()&#123; System.out.println("你好，我来自ASchool"); teacher.teaching(); &#125;&#125;public class Test&#123; public static void main(String args[])&#123; MathTeacher mathTeacher = new MathTeacher(); ATeacher aTeacher1 = new ATeacher(mathTeacher); aTeacher1.teaching(); ChineseTeacher chineseTeacher = new ChineseTeacher(); ATeacher aTeacher2 = new ATeacher(chineseTeacher); aTeacher2.teaching(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类集框架]]></title>
    <url>%2Fpages%2F85b5073b%2F</url>
    <content type="text"><![CDATA[类集框架是一组类和接口； 位于java.until包当中； 主要用于存储盒管理对象； 主要分为三大类：集合(Set)、列表(List)和映射(Map)。 类集框架的主体结构 Collection为单列集合，Map为双列集合。 Collection接口中的方法 方法 功能 boolean add（Object o） 向集合中加入一个对象。 void clear（） 删除集合当中的所有对象。 boolean isEmpty（） 判断集合是否为空，如果为空返回true。 remove（Object o） 从集合中删除一个对象的引用。 int size（） 返回集合中元素的数目。 Iterator接口 主要用于迭代访问（即遍历）整个Collection中的元素，因此Iterator对象也被称为迭代器。 方法 作用 hasNet() 判断当前迭代器中是否还有下一个元素，返回值为boolean值。 next() 返回当前迭代器下一个元素。 示例：12345678910111213141516171819202122import java.util.Set;import java.util.HashSet;import java.util.Iterator;public class TestIterator&#123; public static void main(String args[])&#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add("a"); set.add("b"); set.add("c"); set.add("d"); set.add("e"); //调用Set对象的Iterator方法生成一个迭代器对象，该对象遍历整个Set Iterator&lt;String&gt; it = set.iterator(); //判断Set集合中是否存在下一个元素 while(it.hasNext())&#123; //取出Set集合中的元素 String s = it.next(); System.out.println(s); &#125; &#125;&#125; ListIterator接口 可以按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。 方法 功能 void add(Object o) 将指定的元素插入列表。 boolean hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回true。 Object previous() 返回列表中的前一个元素。 void remove() 从列表中移除由next或previous返回的最后一个元素。 示例：12345678910111213141516171819import java.util.*;public class Test&#123; public static void main(String args[]) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("Monday"); list.add("Tuesday"); list.add("Wednesday"); list.add("Thursday"); System.out.println(list); //生成一个ListIterator对象 ListIterator it = list.listIterator(list.size()); //调用hasPrevious()方法判断是否存在元素 while(it.hasPrevious())&#123; //调用previous()方法返回元素 Object obj = it.previous(); System.out.println(obj); &#125; &#125;&#125; 集合（Set） 集合中的对象不按特定方式排序，并且没有重复对象。 HashSet集合 HashSet是Set接口的一个实现类，它所储存的元素时不可重复且无序的。根据对象的哈希值来确定元素在集合中的储存位置，因此具有良好的存取和查找性能。 示例：123456789101112131415161718192021222324252627282930import java.util.Set;import java.util.HashSet;public class TestSet&#123; public static void main(String args[])&#123; //生成HashSet对象并向上转型为Set Set&lt;String&gt; set =new HashSet&lt;String&gt;(); //定义一个boolean型变量b1接受 isEmpty（）方法返回值 boolean b1 = set.isEmpty(); System.out.println(b1); set.add("a"); set.add("b"); set.add("c"); set.add("d"); set.add("e"); set.add("f"); boolean b2 =set.isEmpty(); System.out.println(b2); //调用size（）方法获取集合长度 int i =set.size(); System.out.println("初始状态set集合中元素的数目" + i); //调用remove（）方法移除对象d set.remove("d"); int j = set.size(); System.out.println("处理之后set集合中元素的数目" + j); &#125;&#125; TreeSet集合 它内部采用自平衡点排序二叉树来储存元素，这样的结构保证TreeSet集合没有重复的元素，并且可以对元素进行排序。 二叉树 二叉树是指每个节点最多有两个子节点的有序树，每个节点及其子节点组成的树称为子树，通常左侧的节点称为“左子树”，右侧的的子节点称为“右子树”。 示例：1234567891011121314151617import java.util.*;public class Test01&#123; public static void main(String args[])&#123; //创建TreeSet集合 TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(); ts.add("10"); ts.add("50"); ts.add("20"); ts.add("40"); ts.add("30"); //获取Iterator对象 Iterator it = ts.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; 结果： 列表（List） 集合中对象按照索引位置排序，即元素的存入和取出顺序一致，可以有重复对象。 ArrayList ArrayList的底层是使用一个数组来保存元素，当增加或删除指定位置的元素时，会创建新的数组，效率较低，因此不适合做大量的增删操作。但是这种数组的结构允许程序通过索引的方式来访问元素，因此使用ArryList集合查找元素很便捷。 示例：123456789101112131415161718192021import java.util.List;import java.util.ArrayList;public class Test&#123; public static void main(String args[])&#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); //向ArrayList中存入数据 arrayList.add("a"); arrayList.add("b"); arrayList.add("c"); arrayList.add("d"); //移除这个对象 arrayList.remove(2); //从ArrayList中取数据 for(int i = 0; i &lt; arrayList.size(); i++)&#123; String s = arrayList.get(i); System.out.println(s); &#125; &#125;&#125; LinkedList 内部维护了一个双向循环链表，链表中的每一个元素都使用引用的方式来记住它的前一个元素和后一个元素，插入一个新元素，只需修改元素之间的这种引用关系即可。 示例：123456789101112131415161718192021import java.util.List;import java.util.LinkedList;public class Test01&#123; public static void main(String args[])&#123; //创建LinkedList集合 LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); //向集合中添加元素 link.add("One"); link.add("Two"); link.add("Three"); link.add("Four"); //取出并打印该集合中的所有元素 System.out.println(link.toString()); //向指定位置插入元素 link.add(2,"插个队"); System.out.println(link); //移除指定位置的元素 link.remove(2); System.out.println(link); &#125;&#125; 映射（Map） 集合中的每一个元素包含一个键对象和一个值对象，键不可重复，值可以重复。 键对象 值对象 key1 value1 key2 value2 key3 value3 Map接口中的方法 方法 作用 void clear() 从此映射中移除所有映射关系（可选操作）。 boolean containsKey（Object Key） 如果此映射包含指定键的映射关系，则返回 true。 boolean equals（Object o） 比较指定的对象与此映射是否相等。 get（Object key） 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回null。 boolean isEmpty（） 如果此映射未包含键-值映射关系，则返回 true。 put（） 将指定的值与此映射中的指定键关联。 remove（Object key） 如果存在一个键的映射关系，则将其从此映射中移除。 int size（） 返回此Map中的键值对数目。 Map与HashMap示例：12345678910111213141516import java.util.Map;import java.util.HashMap;public class Test&#123; public static void main(String args[])&#123; //生成HashMap对象并向上转型为Map Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //向map中添加键值对 map.put("1","One"); map.put("2","Two"); map.put("3","Three"); //调用get（Object key）方法，返回指定键所映射的值； //如果对于该键来说，此映射不包含任何映射关系，则返回 null。 String s = map.get("2"); System.out.println(s); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取键盘输入]]></title>
    <url>%2Fpages%2F828295ba%2F</url>
    <content type="text"><![CDATA[123456789/**Java获取键盘输入值*/public static void main(String args[])&#123; Scanner sc = new Scanner(Systen.in); String s = sc.nextLine(); //接受字符和字符串类型的输入 int age = sc.nextInt(); float salary = sc.nextFloat();&#125; 简单运行、退出方法12345678910111213141516171819202122import java.util.Scanner;public class Test &#123; public static void main(String args[]) &#123; int t = 1;itcast : while(t &gt; 0) &#123; System.out.println("1.运行：\n" + "2.退出："); Scanner sc1 = new Scanner(System.in); int i = sc1.nextInt(); switch(i) &#123; case 1: //这里输入具体的计算程序 break; case 2: break itcast; default: System.out.println("输入有误，请重新输入"); break; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口应用]]></title>
    <url>%2Fpages%2F75336bdc%2F</url>
    <content type="text"><![CDATA[接口定义一种标准： 通过interface定义； 函数都是抽象函数（只有函数没有函数体）； 子类通过implements实现；对接口里面的抽象函数进行override；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/***定义一个Printer接口，通过HPPrinter，CanonPrinter两个子类去实现*/package printer; //定义一个Printer接口interface Printer&#123; public void open(); public void print(String s); public void close();&#125;//定义HPPrinter去implements Printer接口class HPPrinter implements Printer&#123; @Override public void open()&#123; System.out.println("HPPrinter open"); &#125; public void print(String s)&#123; System.out.println("HPPrinter print:" + s); &#125; public void close()&#123; System.out.println("HPPrinter close"); &#125;&#125;//定义CanonPrinter去implements Printer接口class CanonPrinter implements Printer&#123; @Override private void clean()&#123; System.out.println("clean"); &#125; public void open()&#123; System.out.println("CanonPrinter open"); &#125; public void print(String s)&#123; System.out.println("CanonPrinter print:" + s); &#125; public void close()&#123; this.clean(); System.out.println("CanonPrinter close"); &#125;&#125;//静态工厂方法模式class PrinterFactory&#123;//定义一个静态函数getPrinter(int flag)，返回值类型为Printer public static Printer getPrinter(int flag)&#123; Printer printer = null;//根据用户选择生成新的对象，并向上转型为Printer类型 if (flag == 0)&#123; printer = new HPPrinter(); &#125; else if(flag == 1)&#123; printer = new CanonPrinter(); &#125; return printer; &#125;&#125;//定义一个主函数，对函数进行调用class Test&#123; public static void main(String args[])&#123; int flag = 1; //工厂方法模式调用 类名+函数 Printer printer = PrinterFactory.getPrinter(flag); printer.open(); printer.print("Test"); printer.close(); &#125;&#125; 工厂方法简单工厂模式 Java 简单工厂模式（Simple Factory Pattern）又叫静态工厂方法模式（Static FactoryMethod Pattern），通过专门定义一个类来负责创建其他类的实例（将生成对象的代码封装在工厂类中），被创建的实例通常都具有共同的父类。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓编译错误]]></title>
    <url>%2Fpages%2F3f4bb699%2F</url>
    <content type="text"><![CDATA[记一次Android studio错误，错误如下： D:\Android\Projects\JustJava\app\src\main\res\layout\activity_main.xmlError:(47) Error parsing XML: not well-formed (invalid token)D:\Android\Projects\JustJava\app\build\intermediates\res\merged\debug\layout\activitymain.xmlError:(47) Error parsing XML: not well-formed (invalid token)Error:java.lang.RuntimeException: com.android.ide.common.process.ProcessException: Failed to execute aaptError:com.android.ide.common.process.ProcessException: Failed to execute aaptError:java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: Error while executing process C:\Users\Jay\AppData\Local\Android\Sdk\build-tools\25.0.2\aapt.exe with arguments {package -f –no-crunch -I C:\Users\Jay\AppData\Local\Android\Sdk\platforms\android-25\android.jar -M \?\D:\Android\Projects\JustJava\app\build\intermediates\manifests\instant-run\debug\AndroidManifest.xml -S D:\Android\Projects\JustJava\app\build\intermediates\res\merged\debug -m -J \?\D:\Android\Projects\JustJava\app\build\generated\source\r\debug -F D:\Android\Projects\JustJava\app\build\intermediates\res\resources-debug.ap –debug-mode –custom-package com.roojay.android.justjava -0 apk –preferred-density xxhdpi –output-text-symbols \?\D:\Android\Projects\JustJava\app\build\intermediates\symbols\debug –no-version-vectors}Error:com.android.ide.common.process.ProcessException: Error while executing process C:\Users\Jay\AppData\Local\Android\Sdk\build-tools\25.0.2\aapt.exe with arguments {package -f –no-crunch -I C:\Users\Jay\AppData\Local\Android\Sdk\platforms\android-25\android.jar -M \?\D:\Android\Projects\JustJava\app\build\intermediates\manifests\instant-run\debug\AndroidManifest.xml -S D:\Android\Projects\JustJava\app\build\intermediates\res\merged\debug -m -J \?\D:\Android\Projects\JustJava\app\build\generated\source\r\debug -F D:\Android\Projects\JustJava\app\build\intermediates\res\resources-debug.ap_ –debug-mode –custom-package com.roojay.android.justjava -0 apk –preferred-density xxhdpi –output-text-symbols \?\D:\Android\Projects\JustJava\app\build\intermediates\symbols\debug –no-version-vectors}Error:org.gradle.process.internal.ExecException: Process ‘command ‘C:\Users\Jay\AppData\Local\Android\Sdk\build-tools\25.0.2\aapt.exe’’ finished with non-zero exit value 1 最终发现是自己activity_main.xml中错将android:id=”@+id/p_text_view” 写成了 android:=”@+id/p_text_view”。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未知错误]]></title>
    <url>%2Fpages%2F11ecd5a9%2F</url>
    <content type="text"><![CDATA[两次遇到同一个错误： ERROR Asset render failed: css/main.cssError: D:/blog/blog/themes/next/source/css/_common/components/highlight/highligh t.styl:78:30 两次解决无果，github提问作者，作者回应升级下 hexo-renderer-stylus 插件，升级之后并没有解决错误。之后只得重新安装配置hexo，问题得以解决。]]></content>
      <tags>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeTest]]></title>
    <url>%2Fpages%2F24709d34%2F</url>
    <content type="text"><![CDATA[12345public class CodeTest&#123; public static void main(String args[])&#123; system.out.println("Hello Hexo!") &#125;&#125;]]></content>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2Fpages%2F784dd132%2F</url>
    <content type="text"><![CDATA[$ hexo new “My New Post” $ hexo server $ hexo generate $ hexo deploy]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
