[{"title":"jQuery基础","url":"%2Fpages%2F889563%2F","content":"> CDN 方式引入 jQuery\n<script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"></script>\n\n## 选择器操作 DOM 节点\n* $(\"选择器\"); 可以通过选择器选择 DOM 节点\n* jQuery(\"h1\"); 等同于 $(\"h1\"); 返回 h1\n* $(\"h1\").text(); 返回 h1 里面的 text\n* $(\"h1\").text(\"Hello World!\") 更改覆盖 h1 的内容\n\n**注意DOM 加载完成之后 jQuery 开始运行，否则 jQuery 操作会被覆盖，不会生效。**\n```javascript\n// 文档加载完成后执行替换方法\njQuery(document).ready(function(){\n    $(\"h1\").text(\"Hello World!);\n});\n// 或者使用以下方法\n$(document).ready(function(){\n    $(\"h1\").text(\"Hello World!);\n});\n```\n\n### 伪类选择器\n```javascript\n.class li:first; // 选择列表里面的第一个元素\n.class li:last; // 选择列表里面的最后一个元素\n.class li:odd; // 选择列表里面的奇数位元素\n.class li:even; // 选择列表里面的偶数位元素\n```\n## 遍历寻找操作 DOM 节点\n> 速度快于选择器操作\n```javascript\n$(\".class\").find(\"li\");\n```\n### 遍历伪类选择\n```javascript\n$(\".class\").first(); // 选择列表第一个元素\n$(\".class\").last(); // 选择列表最后一个元素\n$(\".class\").odd(); // 选择列表奇数位元素\n$(\".class\").even(); // 选择列表偶数位元素\n```\n###  上下遍历\n\n```javascript\n$(\".class\").parent(\"li\"); // 向上一层遍历，得到直系父元素\n$(\".class\").children(\"li\"); // 向下遍历，得到直系子元素\n```","tags":["jQuery"],"categories":["JavaScript"]},{"title":"变量作用域","url":"%2Fpages%2F7395d6fb%2F","content":"## 变量作用域\n* JavaScript 的函数可以嵌套，内部函数可以访问外部函数定义的变量，反之则不行。\n* `var`和`let`创建的变量区别在于:\n  1. `var`声明的变量作用域为最近的函数块，`let`声明的变量作用域为最近的闭合块，往往小于函数块。\n  2. `var`声明的变量会被提升到作用域的头部，但是赋值不会被提升，在实际声明前使用会抛出`undefined`。\n  3. `let`声明不受变量提升的约束，这意味着`let`声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 ReferenceError（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。这个变量处于从块开始到 let 初始化处理的”暂存死区“之中。`let`声明的变量不能在实际声明之前使用，否则会抛出`ReferenceError`异常。","tags":["YouDon'tKnowJavaScript"],"categories":["JavaScript"]},{"title":"css基础","url":"%2Fpages%2Feda1a9a9%2F","content":"\n## CSS 导入\n\n> 在 HTML 中引入 CSS 的方法主要有四种，它们分别是行内式、内嵌式、链接式和导入式。\n\n1. 行内式\n* 在标记的 style 属性中设定 CSS 样式。\n\n```html\n     <p style=color:white; background-color:blue;>\n     Tihs is a test text.\n     </p>\n```\n\n2. 内嵌式\n\n* 将 CSS 样式集中写在网页的`<head></head>`中的`<style></style>`标签对中。\n\n* 缺点是对于一个包含很多网页的网站，在每个网页中使用嵌入式，进行修改样式时非常麻烦。单一网页可以考虑使用嵌入式。\n\n```html\n     <head>\n       <style type=\"text/css\">\n       p {\n         color:red;\n       }\n       </style>\n     </head>\n```\n\n3. 导入式\n\n* 使用 CSS 的规则将外部CSS文件将一个独立的`.css`文件引入 HTML 文件中，`<style>`标记写在`<head>`标记中。\n\n```html\n   <style type=\"text/css\">\n   \t@import\"mystyle.css'\n   </style>\n```\n\n4. 链接式\n\n* 最常用的的一种方式。\n\n```html\n   <head>\n     <link rel=\"stylesheet\" href=\"src/test.css\" type=\"text/css\">\n   </head>\n```\n## margin\n\n> margin 属性为给定元素设置所有四个（上下左右）方向的外边距属性。四个外边距属性设置分别是： margin-top， margin-right， margin-bottom 和 margin-left 。指定的外边距允许为负数。\n\n| 语法                          | 值       | 例子                    | 含义                              |\n| ----------------------------- | -------- | ----------------------- | --------------------------------- |\n| margin: style                 | 单值语法 | margin: 1em;            | 指定四周外边距都为1em             |\n| margin: vertical horizontal   | 二值语法 | margin: 5% auto;        | 上下为5%，左右为auto              |\n| margin: top horizontal bottom | 三值语法 | margin: 1em auto 2em;   | 上为1em，左右为auto，下为2em      |\n| margin: top right bottom left | 四值语法 | margin: 2px 1em 0 auto; | 上为2px，右为1em，下为0，左为auto |\n\n## 选择符\n\n> 选择符用于定位我们想要样式化的网页 HTML 元素,可以选择一个或多个需要添加样式的元素。\n\n| 选择符      | 选择内容                                   | 示例      |\n| ----------- | ------------------------------------------ | --------- |\n| 元素 选择符 | 标签内所有元素                             | p         |\n| ID 选择符   | 指定ID的元素                               | #my-id    |\n| Clss 选择符 | 指定Class的元素                            | .my-class |\n| 属性 选择符 | 拥有指定属性的元素                         | img[src]  |\n| 伪类 选择符 | 指定的元素，但是需要在特殊的状态，比如悬停 | a:hover   |\n\n### 简单选择器（Simple selectors）\n\n> 通过`元素类型`、`class`或 `id` 匹配一个或多个元素。\n\n### 属性选择器（Attribute selectors）\n\n> 通过`属性/属性值`匹配一个或多个元素。\n\n* [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。\n* [attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。\n* [attr~=val]：该选择器仅选择 attr 属性的值（以空格间隔出多个值）中有包含 val 值的所有元素，比如位于被空格分隔的多个类（class）中的一个类。\n* [attr|=val] : 选择attr属性的值以val（包括val）或val-开头的元素。\n* [attr^=val] : 选择attr属性的值以val开头（包括val）的元素。\n* [attr$=val] : 选择attr属性的值以val结尾（包括val）的元素。\n* [attr*=val] : 选择attr属性的值中包含字符串val的元素。\n\n### 伪类（Pseudo-classes）\n\n> 一个 CSS  伪类（pseudo-class） 是一个以冒号(:)作为前缀的关键字，当元素需要在特定状态下的设置表现样式时，往元素的选择器后面加上对应的伪类（pseudo-class）。\n> 例如：页面上有一个链接， 有四种状态：\n\n1. 未点击状态显示蓝色：\n\n```css\na:link { color: blue; }\n```\n\n2. 已点击状态显示紫色：\n\n```css\na:visited { color: purple; }\n```\n\n3. 鼠标悬停状态显示红色：\n\n```css\na:hover { color: red;  }\n```\n\n4. 鼠标点击状态显示绿色：\n\n```css\na:active { color: green; }\n\n```\n\n多个状态同时设置，按照以上先后顺序排列。\n\n### 伪元素（Pseudo-elements）\n\n> 以冒号(::)作为前缀的关键字，添加到选择器后面选择某个元素的某个部分。例如每个段落的第一个字，或者某个元素之前生成的内容。\n\n* `::after`在已选中元素尾部创建最后一个子元素，通常会配合 content 属性来为该元素添加装饰内容。\n\n```css\n/*在链接后面加上一个箭头←*/\na::after { content: \"←\";}\n```\n\n* `::before` 在已选中元素头部创建第一个子元素。\n\n```css\n/*在链接前面加上一个箭头→*/\na::after { content: \"→\";}\n```\n\n* `::first-letter`会选中一整块文字第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。\n\n```css\n/* 使每段开头的第一个字母变红变大 */\np::first-letter {  /* 使用:first来兼容IE8- */\n  color: red;\n  font-size: 130%;\n}\n```\n\n* `::first-line`将样式只应用于一个元素的首行。首行文本的数量取决于元素的宽，document 的宽和文本的字号。\n* `::first-line` 伪元素**只作用于块容器中**,所以`::first-line`伪元素只能在一个display值为block, inline-block, table-cell 或者 table-caption中有用.。在其他的类型中`::first-line`是不起作用的。\n* `::selection`应用于文档中被用户选中高亮的部分（比如使用鼠标或其他选择设备选中的部分）,ecko 引擎需要加前缀（-moz）。\n\n```css\n/* 将被选中的任何文本渲染为金黄色和红色背景 */\n::-moz-selection {\n  color: gold;\n  background: red;\n}\n::selection {\n  color: gold;\n  background: red;\n}\n```\n\n### 组合器（Combinators）\n\n> 以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，只选择 divs 的直系子节点的段落，或者直接跟在 headings 后面的段落。\n\n| 组合器 | 选择值                                                                                                  |\n| ------ | ------------------------------------------------------------------------------------------------------- |\n| A,B    | 匹配同时满足A和B的任意元素                                                                              |\n| A B    | 匹配任意元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）                           |\n| A > B  | 匹配任意元素，满足条件：B是A的直接子节点                                                                |\n| A + B  | 匹配任意元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面）                    |\n| A ~ B  | 匹配任意元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A） |\n\n### 多用选择器（Multiple selectors）\n\n> 以逗号分隔开的多个选择器放在一个 CSS 规则下面， 以将一组声明应用于由这些选择器选择的所有元素。\n\n## 盒模型\n\n> 网页上的所有的元素都包含在一个个盒子中。在 CSS 里面设置它们的尺寸，颜色，位置等等。\n\n* 内边距（padding）： 围绕着内容的空间（比如围绕段落的空间）\n* 边框（border）：  紧接着内边距的实体线段\n* 外边距(margin) ：  围绕元素外部的空间\n\n ![box](src/box-model.png)\n\n* width：  属于一个元素的宽\n* background-color： 元素内容和内边距之后的颜色\n* color： 元素内容的颜色（通常是文本）\n* text-shadow： 为元素内的文本设置阴影\n* display：  设置元素的显示模式\n* position：fixed  位置保持不动\n\n## 单位长度\n\n### px em\n\n* px ：像素 (px) 是一种绝对单位（ absolute units）， 因为无论其他相关的设置怎么变化，像素指定的值是不会变化的。\n* em ：相对长度单位，相对于当前文本内的字体尺寸。\n\n### px 与em转换\n\n任意浏览器的默认字体高度为 16px（16像素），所有未经调整的浏览器都符合: 1em=16px，那么10px=0.625em。<br>\n为了简化font-size的换算，可以在 css 中的 body 选择器中声明 `font-size: 62.5%`，这时`10px=1em`。\n\n## 阴影\n\n> box-shadow 属性向元素添加一个或多个阴影。\n\n```css\nbox-shadow: h-shadow v-shadow blur spread color inset;\n```\n\n| 值       | 含义                                   |\n| -------- | -------------------------------------- |\n| h-shadow | 必需。水平阴影。允许负值。             |\n| v-shadow | 必需。垂直阴影。允许负值。             |\n| blur     | 可选。模糊距离。                       |\n| spread   | 可选。阴影尺寸。                       |\n| color    | 可选。阴影颜色。                       |\n| inset    | 可选。将外部阴影(outset)改为内部阴影。 |\n\n## 布局\n\n> 一个好的布局，能将网页内容更完美的展示出来。\n\n### display 元素显示\n\n> CSS 中最重要的控制布局的属性，用来设置一个元素应该如何显示，每一个元素都有一个默认的`display`值。\n> 对于大多数元素它们的默认值通常是`block`或`inline`。\n\n* block：块级元素。块级元素通常会占用容器的全部宽度，在其开始和结束位置都是换行符。常见的块级元素有：`h1`、`div`、`p`和`form`等，HTML5 中的新元素：`header`、`footer`和`section`等。\n* inline：行内元素。行内元素只需要必要的宽度，不会强制换行打乱已有元素布局。常见的行内元素有：`span`和`a`。\n* none：隐藏某个元素，且隐藏的元素不会占据任何空间。一些特殊元素的默认 display 值是它，例如 `script`。 `display:none` 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。\n\n### visibility 元素可见性\n\nvisibility 属性有两种用法：\n\n1. 值为`hidden`时隐藏元素，并将其所占空间用空白填充。\n2. 值为`collapse`时隐藏表格的一行或一列，用于快速从表格中删除一行或一列。\n\n* **`display:none`和`visibility:hidden`的区别：**\n  * `display:none`隐藏某个元素时，隐藏的元素不会占据任何空间。\n  * `visibility:hidden`可以隐藏元素，但是隐藏的元素仍然占用原来大小的空间。\n\n## Google 原色\n\n* 蓝色 #4285f3\n* 红色 #ea4335\n* 绿色 #34a853\n* 黄色 #fbbc05\n* 黑色 #1c262f\n\ngoogle蓝 #2196f3\n按钮红 #f50057\ngoogle绿 #0f9d58","tags":["CSS"],"categories":["CSS"]},{"title":"圣杯布局","url":"%2Fpages%2F505644b3%2F","content":"\n> 圣杯布局是三栏式布局的一种经典解决方案，来源于 Matthew Levine 于 2006 年发表在 Alistapart 上的一篇文章。[原文链接](https://alistapart.com/article/holygrail)，其主要解决以下几种要求：\n\n* 两边侧栏固定宽度，中间栏宽度自适应，\n* 中间栏要放在文档流的前面以优先渲染。\n* 其父元素的高度始终是由三栏中高度最高的元素确定。\n\n## 第一步 建立基本框架\n\n写出基本的 html 框架，构建出基本盒模型，包括`header`, `container`和`footer`三个主体结构，再向`container`中加入三栏：\n\n```html\n<div class=\"header\"></div>\n<div class=\"container\">\n    <div class=\"column center\"></div>\n    <div class=\"column left\"></div>\n    <div class=\"column right\"></div>\n</div>\n<div class=\"footer\"></div>\n```\n\n### 第二步 构建基础布局\n\n将 `container` 的内边距设置为左右两侧边栏各自的宽度，为两侧边栏留下空间。为三栏设置合适的宽度(`center`宽度为 100%，`left`宽度为 120px，`right`宽度为240px)，并且将三者设为向左浮动，同时清除`footer`的上下环境，避免其浮动。最后将`body`的最小宽度设为 480px(2*LC width + RC width)，避免因为`center`部分的宽度小`left`和`right`的宽度导致布局乱掉。\n\n```css\n        body {\n            padding: 0;\n            margin: 0; /* 初始化LCD */\n            min-width: 480px;/* 2*LC-width + RC-width */\n        }\n        .header, .footer {\n            background-color: #1c262f;\n            color: white;\n            text-align: center;\n            font-size: 2em;\n        }\n        .container {\n            padding-left: 120px;  /* LC-width */\n            padding-right: 240px; /* RC-width */\n        }\n        .column {\n            float: left;\n            color: white;\n            position: relative;\n            text-align: justify; /* 文字两端对齐 */\n        }\n        h1 {\n            text-align: center;\n        }\n        .center {\n            background-color: #4285f3;\n            width: 100%;\n        }\n        .left {\n            background-color: #ea4335;\n            width: 120px; /* LC-width */\n        }\n        .right {\n            background-color: #34a853;\n            width: 240px;  /* RC-width */\n        }\n        .footer {\n            clear: both;\n        }\n```\n\n### 第三步 将侧栏放到合适的位置\n\n设置三栏的定位属性为相对定位。设置左边栏的外边距`margin-left: -100%;`(中间栏所占据的宽度)，左边栏上移到中间栏的左边，但是与中间栏部分重叠。此时利用相对定位属性，为左边栏设置一个与其等宽的偏移量`left：-120px;`(相对于`container`的左边线向左偏移 120px)，左边栏刚好占据`container`的左内边距位置。最后设置右边栏的外边距`margin-right: -240px;`(右边栏自身宽度)，使右边栏占据`container`的右内边距位置。\n\n```css\n        .column {\n            float: left;\n            position: relative;\n        }\n        .left {\n            margin-left: -100%;\n            left: -120px;\n        }\n        .right {\n            margin-right: -240px;\n        }\n```","tags":["CSS"],"categories":["CSS"]},{"title":"盒子模型","url":"%2Fpages%2F998dffd6%2F","content":"> 浏览器中的每个视图可以看成是一个一个嵌套的盒子.\n## box-size\n\n* 元素大小 = boder + padding + contentwidth\n* box-size: boder-size;（兼容性） 它会让系统计算元素大小时会将 boder padding 包括在内。不包含外边距(margin)。\n\n```css\n{\n -webkit-box-size: boder-size;\n -ms-box-size: boder-size;\n -moz-box-size: boder-size;\n}\n```\n\n## 浏览器前缀\n\n* -webkit\n* -ms\n* -moz\n\n## flex\n\n> 弹性布局\n\n* 用于 Chrome 29+、IE 11+ 和 Mozilla 28+。要支持 Safari，必须添加 -webkit- 前缀：\n\n```css\n{\n    display: -webkit-flex;\n    display: flex;\n}\n```\n\n","tags":["CSS"],"categories":["CSS"]},{"title":"进制快速转换","url":"%2Fpages%2F8b41c91c%2F","content":"## 十进制转其他进制\n\n```javascript\nconst i = 10;\ni.toString(2);  // 2 进制 1010\ni.toString(8);  // 8 进制 12\ni.toString(16);  // 16 进制 a\ni.toString(32);  // 32 进制 a\n\n```\n\n## 其他进制转十进制\n\n```javascript\nparsetInt(x, 2); // 2 进制转 10进制\nparsetInt(x, 8); // 8 进制转 10 进制\nparsetInt(x, 16); // 16 进制转 10 进制\n\n```\n\n## 非十进制转十进制\n\n先转化为10进制， 然后再利用toString(参数)， 转化成不同的进制。\n\n```javascript\nparsetInt(x, 2).toString(8); // 2 进制转 8进制\n```","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"数组与字符串常用方法","url":"%2Fpages%2F4b02d38a%2F","content":"## split() 将字符串分割成数组\n\nstr.split('分隔符', 返回数组最大的长度)\n\n根据分隔符(字符串或者正则表达式)将一个字符串分割成数组。\n\n```javascript\nconst str = 'wind rain fire';\nconst arr = str.split(' ');\nconsole.log(arr); // arr['wind', 'rain', 'fire']\n```\n\n## join() 数组连接成一个字符串\n\narr.join('分隔符')\n\n分隔符默认值为`,`\n将数组（或一个类数组对象）的所有元素使用分隔符连接成一个新字符串。\n\n```javascript\nconst arr = ['wind', 'rain', 'fire'];\nconst str = arr.join('+');\nconsole.log(str); // wind+rain+fire\n```\n\n## 字符串快速排序\n\n```javascript\nconst strSort = str => str.split('').sort().join('');\nstrSort(str);\n```\n## map() 创建新数组\n\narr.map(callback)\n\n创建一个新数组，新数组的每个元素都是 callback 函数的结果。\n\n```javascript\nconst arr = [1, 2, 3];\nconst newArr = arr.map(num => num * 2);\nconsole.log(newArr); // newArr[2, 4, 6]\n```\n\n## 数组取最大最小值\n\n```javascript\nMath.max.apply(null, arr);  // 取数组最大值\nMath.min.apply(null, arr);  // 取数组最小值\n```\nES6 扩展 rest 不定参数写法：\n\n```javascript\nMath.max(...arr);  // 取数组最大值\nMath.min(...arr);  // 取数组最小值\n```\n\n## filter() 数组中取通过测试的值\n\nfilter(fn)\n\n创建一个新数组, 其包含通过 fn 函数测试返回值为 true 的所有元素。\n\n```javascript\nlet [...arr] = [1, 2, 4, 7, 6];\n\nconst isOdd = num => num % 2;\n\nlet odd = arr.filter(isOdd); // odd is [1, 7]\n```\n\n## slice() 取一部分数组\n\nslice(start, end)\n\n* start, end 数组下标\n\n返回一个从 start 到 end（不包括 end）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。\n\n```javascript\nlet arr = ['a', 'b', 'c', 'd'];\nlet arr13 = arr.slice(1, 3);\nconsole.log(arr); // ['a', 'b', 'c', 'd']\nconsole.log(arr13); // ['b', 'c']\n```\n如果参数为负数，例如`start = -3, end = -1`，就表示倒数第三位到倒数第一位，不包括\n## reduce() 数组求和\n\n```javascript\nlet arr = [1, 3, 5];\nlet sumArr = arr.reduce((sum, value) => sum + value, 0);\n// sumArr is 9.\n```\nsum 上一次调用回调返回的值，或者是提供的初始值 0;\nnum 数组中正在处理的元素;\n0 可选项，其值用于第一次调用 callback 的第一个参数 sum。如果没有设置初始值，则将数组中的第一个元素作为初始值。空数组调用 reduce 时没有设置初始值将会报错。\n\n## repeat()\n\nstr.repeat(n)\n\n创建 n 个 str 的副本，将其连接在一起返回一个新的字符串。\n\n```javascript\n'ha'.repeat(3); // 'hahaha'\n'ha'.repeat(2); // 'haha'\n```\n## match() 字符串中正则取值\n\nstr.match(regx)\n\n方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，返回匹配值构成的数组。","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"常用排序算法","url":"%2Fpages%2F5b90526d%2F","content":"\n> 转自@ruanyf大神,留作自己备用.\n\n排序算法是将一系列的值按照顺序进行排列的方法。\n## 冒泡排序\n\n### 简介\n\n冒泡排序（Bubble Sort）是最易懂的排序算法，但是效率较低，生产环境中很少使用。\n\n它的基本思想是：\n\n1. 依次比较相邻的两个数，如果不符合排序规则，则调换两个数的位置。这样一遍比较下来，能够保证最大（或最小）的数排在最后一位。\n\n2. 再对最后一位以外的数组，重复前面的过程，直至全部排序完成。\n\n由于每进行一次这个过程，在该次比较的最后一个位置上，正确的数会自己冒出来，就好像“冒泡”一样，这种算法因此得名。\n\n以对数组`[3, 2, 4, 5, 1]`进行从小到大排序为例，步骤如下：\n\n1. 第一位的“3”与第二位的“2”进行比较，3大于2，互换位置，数组变成`[2, 3, 4, 5, 1]`。\n\n2. 第二位的“3”与第三位的“4”进行比较，3小于4，数组不变。\n\n3. 第三位的“4”与第四位的“5”进行比较，4小于5，数组不变。\n\n4. 第四位的“5”与第五位的“1”进行比较，5大于1，互换位置，数组变成`[2, 3, 4, 1, 5]`。\n\n第一轮排序完成，可以看到最后一位的5，已经是正确的数了。然后，再对剩下的数`[2, 3, 4, 1]`重复这个过程，每一轮都会在本轮最后一位上出现正确的数。直至剩下最后一个位置，所有排序结束。\n\n### 算法实现\n\n先定义一个交换函数，作用是交换两个位置的值。\n\n```javascript\nfunction swap(myArray, p1, p2){\n  var temp = myArray[p1];\n  myArray[p1] = myArray[p2];\n  myArray[p2] = temp;\n}\n```\n\n然后定义主函数。\n\n```javascript\nfunction bubbleSort(myArray){\n  var len = myArray.length;\n  var i;\n  var j;\n  var stop;\n\n  for (i = 0; i < len - 1; i++){\n    for (j = 0, stop = len - 1 - i; j < stop; j++){\n      if (myArray[j] > myArray[j + 1]){\n        swap(myArray, j, j + 1);\n      }\n    }\n  }\n\n  return myArray;\n}\n```\n\n## 选择排序\n\n### 简介\n\n选择排序（Selection Sort）与冒泡排序类似，也是依次对相邻的数进行两两比较。不同之处在于，它不是每比较一次就调换位置，而是一轮比较完毕，找到最大值（或最小值）之后，将其放在正确的位置，其他数的位置不变。\n\n以对数组[3, 2, 4, 5, 1] 进行从小到大排序为例，步骤如下：\n\n1. 假定第一位的“3”是最小值。\n\n2. 最小值“3”与第二位的“2”进行比较，2小于3，所以新的最小值是第二位的“2”。\n\n3. 最小值“2”与第三位的“4”进行比较，2小于4，最小值不变。\n\n4. 最小值“2”与第四位的“5”进行比较，2小于5，最小值不变。\n\n5. 最小值“2”与第五位的“1”进行比较，1小于2，所以新的最小值是第五位的“1”。\n\n6. 第五位的“1”与第一位的“3”互换位置，数组变为[1, 2, 4, 5, 3]。\n\n这一轮比较结束后，最小值“1”已经排到正确的位置了，然后对剩下的[2, 4, 5, 3]重复上面的过程。每一轮排序都会将该轮的最小值排到正确的位置，直至剩下最后一个位置，所有排序结束。\n\n### 算法实现\n\n先定义一个交换函数。\n\n```javascript\n\nfunction swap(myArray, p1, p2){\n    var temp = myArray[p1];\n    myArray[p1] = myArray[p2];\n    myArray[p2] = temp;\n}\n\n```\n\n然后定义主函数。\n\n```javascript\n\nfunction selectionSort(myArray){\n\n    var len = myArray.length,\n        min;\n\n    for (i=0; i < len; i++){\n\n        // 将当前位置设为最小值\n        min = i;\n\n        // 检查数组其余部分是否更小\n        for (j=i+1; j < len; j++){\n            if (myArray[j] < myArray[min]){\n                min = j;\n            }\n        }\n\n        // 如果当前位置不是最小值，将其换为最小值\n        if (i != min){\n            swap(myArray, i, min);\n        }\n    }\n\n    return myArray;\n}\n\n```\n\n## 插入排序\n\n### 简介\n\n插入排序（insertion sort）比前面两种排序方法都更有效率。它将数组分成“已排序”和“未排序”两部分，一开始的时候，“已排序”的部分只有一个元素，然后将它后面一个元素从“未排序”部分插入“已排序”部分，从而“已排序”部分增加一个元素，“未排序”部分减少一个元素。以此类推，完成全部排序。\n\n以对数组[3, 2, 4, 5, 1] 进行从小到大排序为例，步骤如下：\n\n1. 将数组分成[3]和[2, 4, 5, 1]两部分，前者是已排序的，后者是未排序的。\n\n2. 取出未排序部分的第一个元素“2”，与已排序部分最后一个元素“3”比较，因为2小于3，所以2排在3前面，整个数组变成[2, 3]和[4, 5, 1]两部分。\n\n3. 取出未排序部分的第一个元素“4”，与已排序部分最后一个元素“3”比较，因为4大于3，所以4排在3后面，整个数组变成[2, 3, 4]和[5, 1]两部分。\n\n4. 取出未排序部分的第一个元素“5”，与已排序部分最后一个元素“4”比较，因为5大于4，所以5排在4后面，整个数组变成[2, 3, 4, 5]和[1]两部分。\n\n5. 取出未排序部分的第一个元素“1”，与已排序部分最后一个元素“5”比较，因为1小于5，所以再与前一个元素“4”比较；因为1小于4，再与前一个元素“3”比较；因为1小于3，再与前一个元素“2”比较；因为小于1小于2，所以“1”排在2的前面，整个数组变成[1, 2, 3, 4, 5]。\n\n### 算法实现\n\n算法的实现如下：\n\n```javascript\n\nfunction insertionSort(myArray) {\n\n    var len     = myArray.length,     // 数组的长度\n        value,                      // 当前比较的值\n        i,                          // 未排序部分的当前位置\n        j;                          // 已排序部分的当前位置\n\n    for (i=0; i < len; i++) {\n\n        // 储存当前位置的值\n        value = myArray[i];\n\n        /*\n         * 当已排序部分的当前元素大于value，\n         * 就将当前元素向后移一位，再将前一位与value比较\n         */\n        for (j=i-1; j > -1 && myArray[j] > value; j--) {\n            myArray[j+1] = myArray[j];\n        }\n\n        myArray[j+1] = value;\n    }\n\n    return myArray;\n}\n\n```\n\n## 合并排序\n\n### 简介\n\n前面三种排序算法只有教学价值，因为效率低，很少实际使用。合并排序（Merge sort）则是一种被广泛使用的排序方法。\n\n它的基本思想是，将两个已经排序的数组合并，要比从头开始排序所有元素来得快。因此，可以将数组拆开，分成n个只有一个元素的数组，然后不断地两两合并，直到全部排序完成。\n\n以对数组[3, 2, 4, 5, 1] 进行从小到大排序为例，步骤如下：\n\n1. 将数组分成[3, 2, 4]和[5, 1]两部分。\n\n2. 将[3, 2, 4]分成[3, 2]和[4]两部分。\n\n3. 将[3, 2]分成[3]和[2]两部分，然后合并成[2, 3]。\n\n4. 将[2, 3]和[4]合并成[2, 3, 4]。\n\n5. 将[5, 1]分成[5]和[1]两部分，然后合并成[1, 5]。\n\n6. 将[2, 3, 4]和[1, 5]合并成[1, 2, 3, 4, 5]。\n\n### 算法实现\n\n这里的关键是如何合并两个已经排序的数组。具体实现请看下面的函数。\n\n```javascript\n\nfunction merge(left, right){\n    var result  = [],\n        il      = 0,\n        ir      = 0;\n\n    while (il < left.length && ir < right.length){\n        if (left[il] < right[ir]){\n            result.push(left[il++]);\n        } else {\n            result.push(right[ir++]);\n        }\n    }\n\n    return result.concat(left.slice(il)).concat(right.slice(ir));\n}\n\n```\n\n上面的merge函数，合并两个已经按升序排好序的数组。首先，比较两个数组的第一个元素，将其中较小的一个放入result数组；然后，将其中较大的一个与另一个数组的第二个元素进行比较，再将其中较小的一个放入result数组的第二个位置。以此类推，直到一个数组的所有元素都进入result数组为止，再将另一个数组剩下的元素接着result数组后面返回（使用concat方法）。\n\n有了merge函数，就可以对任意数组排序了。基本方法是将数组不断地拆成两半，直到每一半只包含零个元素或一个元素为止，然后就用merge函数，将拆成两半的数组不断合并，直到合并成一整个排序完成的数组。\n\n```javascript\n\nfunction mergeSort(myArray){\n\n    if (myArray.length < 2) {\n        return myArray;\n    }\n\n    var middle = Math.floor(myArray.length / 2),\n        left    = myArray.slice(0, middle),\n        right   = myArray.slice(middle);\n\n    return merge(mergeSort(left), mergeSort(right));\n}\n\n```\n\n上面的代码有一个问题，就是返回的是一个全新的数组，会多占用空间。因此，修改上面的函数，使之在原地排序，不多占用空间。\n\n```javascript\n\nfunction mergeSort(myArray){\n\n    if (myArray.length < 2) {\n        return myArray;\n    }\n\n    var middle = Math.floor(myArray.length / 2),\n        left    = myArray.slice(0, middle),\n        right   = myArray.slice(middle),\n        params = merge(mergeSort(left), mergeSort(right));\n\n    // 在返回的数组头部，添加两个元素，第一个是0，第二个是返回的数组长度\n    params.unshift(0, myArray.length);\n\n\t// splice用来替换数组元素，它接受多个参数，\n\t// 第一个是开始替换的位置，第二个是需要替换的个数，后面就是所有新加入的元素。\n\t// 因为splice不接受数组作为参数，所以采用apply的写法。\n\t// 这一句的意思就是原来的myArray数组替换成排序后的myArray\n    myArray.splice.apply(myArray, params);\n\n\t// 返回排序后的数组\n    return myArray;\n}\n\n```\n\n## 快速排序\n\n### 简介\n\n快速排序（quick sort）是公认最快的排序算法之一，有着广泛的应用。\n\n它的基本思想很简单：先确定一个“支点”（pivot），将所有小于“支点”的值都放在该点的左侧，大于“支点”的值都放在该点的右侧，然后对左右两侧不断重复这个过程，直到所有排序完成。\n\n具体做法是：\n\n1. 确定“支点”（pivot）。虽然数组中任意一个值都能作为“支点”，但通常是取数组的中间值。\n\n2. 建立两端的指针。左侧的指针指向数组的第一个元素，右侧的指针指向数组的最后一个元素。\n\n3. 左侧指针的当前值与“支点”进行比较，如果小于“支点”则指针向后移动一位，否则指针停在原地。\n\n4. 右侧指针的当前值与“支点”进行比较，如果大于“支点”则指针向前移动一位，否则指针停在原地。\n\n5. 左侧指针的位置与右侧指针的位置进行比较，如果前者大于等于后者，则本次排序结束；否则，左侧指针的值与右侧指针的值相交换。\n\n6. 对左右两侧重复第2至5步。\n\n以对数组[3, 2, 4, 5, 1] 进行从小到大排序为例，步骤如下：\n\n1. 选择中间值“4”作为“支点”。\n\n2. 第一个元素3小于4，左侧指针向后移动一位；第二个元素2小于4，左侧指针向后移动一位；第三个元素4等于4，左侧指针停在这个位置（数组的第2位）。\n\n3. 倒数第一个元素1小于4，右侧指针停在这个位置（数组的第4位）。\n\n4. 左侧指针的位置（2）小于右侧指针的位置（4），两个位置的值互换，数组变成[3, 2, 1, 5, 4]。\n\n5. 左侧指针向后移动一位，第四个元素5大于4，左侧指针停在这个位置（数组的第3位）。\n\n6. 右侧指针向前移动一位，第四个元素5大于4，右侧指针移动向前移动一位，第三个元素1小于4，右侧指针停在这个位置（数组的第3位）。\n\n7. 左侧指针的位置（3）大于右侧指针的位置（2），本次排序结束。\n\n8. 对 [3, 2, 1]和[5, 4]两部分各自不断重复上述步骤，直到排序完成。\n\n### 算法实现\n\n首先部署一个swap函数，用于互换两个位置的值。\n\n```javascript\n\nfunction swap(myArray, firstIndex, secondIndex){\n    var temp = myArray[firstIndex];\n    myArray[firstIndex] = myArray[secondIndex];\n    myArray[secondIndex] = temp;\n}\n\n```\n\n然后，部署一个partition函数，用于完成一轮排序。\n\n```javascript\n\nfunction partition(myArray, left, right) {\n\n    var pivot   = myArray[Math.floor((right + left) / 2)],\n        i       = left,\n        j       = right;\n\n\n    while (i <= j) {\n\n        while (myArray[i] < pivot) {\n            i++;\n        }\n\n        while (myArray[j] > pivot) {\n            j--;\n        }\n\n        if (i <= j) {\n            swap(myArray, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    return i;\n}\n\n```\n\n接下来，就是递归上面的过程，完成整个排序。\n\n```javascript\n\nfunction quickSort(myArray, left, right) {\n\n\tif (myArray.length < 2) return myArray;\n\n\tleft = (typeof left !== \"number\" ? 0 : left);\n\n\tright = (typeof right !== \"number\" ? myArray.length - 1 : right);\n\n\tvar index  = partition(myArray, left, right);\n\n\t if (left < index - 1) {\n            quickSort(myArray, left, index - 1);\n     }\n\n\t if (index < right) {\n            quickSort(myArray, index, right);\n      }\n\n\t return myArray;\n\n}\n\n```\n\n## 参考链接\n\n- Nicholas C. Zakas, [Computer science in JavaScript: Bubble sort](http://www.nczonline.net/blog/2009/05/26/computer-science-in-javascript-bubble-sort/)\n- Nicholas C. Zakas, [Computer science in JavaScript: Selection sort](http://www.nczonline.net/blog/2012/09/17/computer-science-in-javascript-insertion-sort/)\n- Nicholas C. Zakas, [Computer science in JavaScript: Insertion sort](http://www.nczonline.net/blog/2012/09/17/computer-science-in-javascript-insertion-sort/)\n- Nicholas C. Zakas, [Computer science in JavaScript: Merge sort](http://www.nczonline.net/blog/2012/10/02/computer-science-and-javascript-merge-sort/)\n- Nicholas C. Zakas, [Computer science in JavaScript: Quicksort](http://www.nczonline.net/blog/2012/11/27/computer-science-in-javascript-quicksort/)\n","tags":["算法"],"categories":["编程相关"]},{"title":"常用正则表达式","url":"%2Fpages%2F81d5af05%2F","content":"## 一、校验数字的表达式\n\n1. 数字：`^[0-9]*$`\n\n2. n位的数字：`^\\d{n}$`\n\n3. 至少n位的数字：`^\\d{n,}$`\n\n4. m-n位的数字：`^\\d{m,n}$`\n\n5. 零和非零开头的数字：`^(0|[1-9][0-9]*)$`\n\n6. 非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(.[0-9]{1,2})?$`\n\n7. 带1-2位小数的正数或负数：`^(\\-)?\\d+(\\.\\d{1,2})?$`\n\n8. 正数、负数、和小数：`^(\\-|\\+)?\\d+(\\.\\d+)?$`\n\n9. 有两位小数的正实数：`^[0-9]+(.[0-9]{2})?$`\n\n10. 有1~3位小数的正实数：`^[0-9]+(.[0-9]{1,3})?$`\n\n11. 非零的正整数：`^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$`\n\n12. 非零的负整数：`^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$`\n\n13. 非负整数：`^\\d+$ 或 ^[1-9]\\d*|0$`\n\n14. 非正整数：`^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$`\n\n15. 非负浮点数：`^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$`\n\n16. 非正浮点数：`^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$`\n\n17. 正浮点数：`^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$`\n\n18. 负浮点数：`^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`\n\n19. 浮点数：`^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$`\n\n## 二、校验字符的表达式\n\n1. 汉字：`^[\\u4e00-\\u9fa5]{0,}$`\n\n2. 英文和数字：`^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$`\n\n3. 长度为3-20的所有字符：`^.{3,20}$`\n\n4. 由26个英文字母组成的字符串：`^[A-Za-z]+$`\n\n5. 由26个大写英文字母组成的字符串：`^[A-Z]+$`\n\n6. 由26个小写英文字母组成的字符串：`^[a-z]+$`\n\n7. 由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`\n\n8. 由数字、26个英文字母或者下划线组成的字符串：`^\\w+$ 或 ^\\w{3,20}$`\n\n9. 中文、英文、数字包括下划线：`^[\\u4E00-\\u9FA5A-Za-z0-9_]+$`\n\n10. 中文、英文、数字但不包括下划线等符号：`^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$`\n\n11. 可以输入含有`^%&',;=?$\\`\"等字符：`[^%&',;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+`\n\n## 三、特殊需求表达式\n\n1. Email地址：`^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$`\n\n2. 域名：`[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?`\n\n3. InternetURL：`[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$`\n\n4. 手机号码：    ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n\n5. 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：`^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$`\n\n6. 国内电话号码(0511-4405222、021-87888822)：`\\d{3}-\\d{8}|\\d{4}-\\d{7}`\n\n7. 身份证号(15位、18位数字)：`^\\d{15}|\\d{18}$`\n\n8. 短身份证号码(数字、字母x结尾)：`^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$`\n\n9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$`\n\n10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：`^[a-zA-Z]\\w{5,17}$`\n\n11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：`^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`\n\n12. 日期格式：`^\\d{4}-\\d{1,2}-\\d{1,2}`\n\n13. 一年的12个月(01～09和1～12)：`^(0?[1-9]|1[0-2])$`\n\n14. 一个月的31天(01～09和1～31)：`^((0?[1-9])|((1|2)[0-9])|30|31)$`\n\n15. 钱的输入格式：\n\n\ta. 有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：`^[1-9][0-9]*$`\n\n\tb. 这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：`^(0|[1-9][0-9]*)$`\n\n\tc. 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：`^(0|-?[1-9][0-9]*)$`\n\n\te. 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：`^[0-9]+(.[0-9]+)?$`\n\n\tf. 必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：`^[0-9]+(.[0-9]{2})?$`\n\n\tg. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：`^[0-9]+(.[0-9]{1,2})?$`\n\n\th. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：`^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$`\n\n\ti. 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：`^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$`\n\n**备注**：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n\n16. xml文件：`^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$`\n\n17. 中文字符的正则表达式：`[\\u4e00-\\u9fa5]`\n\n18. 双字节字符：`[^\\x00-\\xff]` (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n\n19. 空白行的正则表达式：`\\n\\s*\\r` (可以用来删除空白行)\n\n20. HTML标记的正则表达式：`<(\\S*?)[^>]*>.*?</\\1>|<.*? />` (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n\n21. 首尾空白字符的正则表达式：`^\\s*|\\s*$或(^\\s*)|(\\s*$)` (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n\n22. 腾讯QQ号：`[1-9][0-9]{4,}` (腾讯QQ号从10000开始)\n\n23. 中国邮政编码：`[1-9]\\d{5}(?!\\d)` (中国邮政编码为6位数字)\n\n24. IP地址：`\\d+\\.\\d+\\.\\d+\\.\\d+` (提取IP地址时有用)\n\n25. IP地址：`((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))`","tags":["RegEx"],"categories":["Tools"]},{"title":"多个SSH管理","url":"%2Fpages%2F8ee164b8%2F","content":"## 多个 SSH key 管理\n\n* 在创建ssh key的时候，将新的密钥进行重新命名，比如id_rsa_coding，使用下面的命令：\n`ssh-keygen -t rsa -C \"roojay520@gmail.com\" -f ~/.ssh/id_rsa_coding`\nb48684451cdeae15e70966c332895a1947144e1e\n\ngit config --global user.name \"roojay\"\ngit config --global user.email \"roojay520@gmail.com\"\n\ngit config --global user.name \"roojay\"\ngit config --global user.email \"roojay@126.com\"\n\nSTATIC_SITE_REPO https://github.com/roojay520/roojay520.github.io\nTARGET_BRANCH master\nGIT_USER_EMAIL roojay520@gmail.com\nGIT_USER_NAME roojay","tags":["SSH"],"categories":["Git"]},{"title":"变量提升","url":"%2Fpages%2F3080460d%2F","content":"## 变量与函数提升\n\n**包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。**\n### 变量提升\n\n例如一个 var = 2；声明，在 javascript 引擎中它实际上被分为 2 个部分， 定义声明var a；和赋值声明 a = 2；第一个定义声明在编译阶段进行，第二个赋值声明要等到执行阶段才会进行。\n\n**例1：**\n\n```javascript\na = 2;\nvar a;\nconsole.log(a); // 2\n```\n上面的例子等同于：\n\n```javascript\nvar a;\n\na = 2;\nconsole.log(a); // 2\n```\n\n**例2：**\n\n```javascript\nconsole.log(a); //undefined\nvar a = 2;\n```\n上面的例子等同于：\n\n```javascript\nvar a;\n\nconsole.log(a); //undefined\na = 2;\n```\n#### let 与 var区别\n\n1. `var`声明的变量作用域为最近的函数块，`let`声明的变量作用域为最近的闭合块，往往小于函数块。\n2. `var`声明的变量会被提升到作用域的头部，但是赋值不会被提升，在实际声明前使用会抛出`undefined`。\n3. `let`声明不受变量提升的约束，这意味着`let`声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 ReferenceError（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。这个变量处于从块开始到 let 初始化处理的”暂存死区“之中。`let`声明的变量不能在实际声明之前使用，否则会抛出`ReferenceError`异常。\n### 函数提升\n\n**函数声明和变量声明都会被提升,但是函数表达式却不会被提升。**\n\n```javascript\nfoo(); // 1\n\nvar foo;\n\nfunction foo() {\n    console.log(1);\n}\n\nfoo = function() {\n    console.log(2);\n};\n```\n上面的 foo() 函数执行会输出 1，而不是 2 。\n上面的代码等同于：\n\n```javascript\nfunction foo() {\n    console.log(1);\n}\n\nfoo(); // 1\n\nfoo = function() {\n    console.log(2);\n};\n```\n**函数会首先被提升，然后才是变量。**\n\n尽管 var foo 在 function foo(){..} 函数之前，但是 function foo(){..} 函数会被优先提升到了函数顶部， var foo 作为重复的声明会被忽略，但是如果后面再次使用函数声明会覆盖前面的声明。\n\n一个普通块内部的变量声明通常会被提升到所在作用域的顶部，例如：\n\n```javascript\nvar tmp = new Date();\n\nfunction foo() {\n    console.log(tmp);\n    if (false) {\n        var tmp = \"hello world\";\n    }\n}\n\nf(); // undefined\n```\nif 块作用域内部的 tmp 变量被提升到了 foo() 函数作用域的顶部，而赋值操作留在了 if 块作用域内部。上面的代码等同于：\n\n```javascript\nvar tmp = new Date();\n\nfunction foo() {\n    var tmp;\n    console.log(tmp);\n    if (false) {\n        tmp = \"hello world\";\n    }\n}\n\nfoo(); // undefined\n```","tags":["YouDon'tKnowJavaScript"],"categories":["JavaScript"]},{"title":"淘宝双飞翼布局","url":"%2Fpages%2Fff1e4b17%2F","content":"## 淘宝双飞翼布局\n\n> 淘宝双飞翼布局和圣杯布局在前半部分的思路都差不多，只是在解决中间栏内容被挡住时所采用的方法不同。双飞翼布局在 main 下多一个增加 div，不使用相对定位，只用浮动和负边距，解决三栏液态式布局。\n\n### DOM 结构\n\n在 DOM 中按照主列、子列、附加列的顺序排列，保证主列优先加载。\n\n```html\n<div class=\"header\">\n        <strong>三栏布局之双飞翼布局</strong>\n    </div>\n    <div class=\"container\">\n        <div class=\"col main\">\n             <div class=\"main-wrap\">我是一个宽度自适应的主列。</div>\n        </div>\n        <div class=\"col sub\">我是一个子列。</div>\n        <div class=\"col extra\">我是一个附加列。</div>\n    </div>\n    <div class=\"footer\"></div>\n```\n\n以上 DOM 结构中，在 main 中添加了一个子 div，用来解决中间列内容被遮挡问题。\n\n### CSS 样式\n\n去掉相对定位的使用，去掉了父容器的 padding，使用中间栏新增 div 的 margin 解决遮挡问题。\n\n```css\n        body {\n            padding: 0;\n            margin: 0;\n            min-width: 440px;\n        }\n        .header,\n        .footer {\n            background-color: ##1c262f;\n            color: white;\n            text-align: center;\n            font-size: 1.5em;\n        }\n        .container {\n            width: 100%;\n            min-height: 200px;\n        }\n        .col {\n            float: left;\n            color: white;\n            text-align: justify; /* 文字两端对齐 */\n            min-height:120px;\n        }\n        .main{\n            width: 100%;\n        }\n        .sub {\n            background-color: ##ea4335;\n            width: 120px;\n            margin-left: -100%;\n        }\n        .extra {\n            background-color: ##34a853;\n            width: 200px;\n            margin-left: -200px;\n        }\n        .main-wrap {\n            margin-left: 120px;\n            margin-right: 200px;\n            background-color: ##4285f3;\n        }\n        .footr {\n            clear: both;\n        }\n```\n\n为 body 加上一个最小宽度(2 * sub width + extra width),避免网页放大时中间栏被挤到消失。","tags":["CSS"],"categories":["CSS"]},{"title":"前端学习资源","url":"%2Fpages%2F422fbc06%2F","content":"## 导航\n\n* 前端导航：http://webjike.com/web.html\n## HTML\n\n* HTML MDN：https://developer.mozilla.org/zh-CN/docs/Web/HTML\n* HTML5 MDN：https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5\n\t* H5资源：http://www.html5tricks.com/\n* HTML语义化\n\n## CSS\n\n* CSS MDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS\n\t* CSS 布局：http://zh.learnlayout.com/\n* CSS3 MDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS3\n* scss 中文网：https://www.sass.hk/\n\t*Sass (3.4.21) 中文文档：http://www.css88.com/doc/sass/#features\n* stylus 中文文档：http://www.zhangxinxu.com/jq/stylus/\n\n\n## JavaScipt\n\n* JavaScript MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript\n* DOM操作（jQuery、React）\n\n## 框架\n\n* Bootstrap 中文网：http://www.bootcss.com/\n* Vue.js\n* React\n* Angular 4\n\n## UI设计\n\n* 免费高清图：https://pixabay.com/\n* 网页背景抓取：http://stylifyme.com/\n* Material中文：https://www.mdui.org/design/#\n* Material：https://www.materialui.co/\n* Flatui：https://flatuicolors.com/\n* Uplabs：https://www.uplabs.com/web\n* 花瓣：http://huaban.com/boards/3511269/\n* 颜色进制转换：http://www.sioe.cn/yingyong/yanse-rgb-16/\n\n* CSS 动画\n* JavaScript 动画\n* 字体\n\t* 汉字标准格式：https://css.hanzi.co/manual\n\t* Google Fonts：https://fonts.google.com/\n\t* Google Fonts 中文版：http://www.googlefonts.cn/\n\t* 360 Google 字体库：https://cdn.baomitu.com/index/fonts\n* ICON\n\t* 在线标签：https://shields.io/\n\t* Awesome 在线 ：http://fontawesome.io/icons/\n\t* Easyicon 下载：http://www.easyicon.net/\n\t* Icon 爱看搜索：http://www.iconpng.com/\n\t* Favico 在线制作：http://www.faviconico.org/favicon\n\t* Material ：https://material.io/icons/\n\t* 阿里巴巴 ：http://www.iconfont.cn/\n\t* Sample： https://simpleicons.org/\n\t* Flaticon：https://www.flaticon.com/\n\n* PS 切图\n* 响应式设计\n* Flexbox 布局\n\t* 阮一峰：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool\n* 网格布局\n\n## Node.js\n\n* node.js 中文网：http://nodejs.cn/\n* node.js 中文社区：https://cnodejs.org/\n\t* 一起学Node.js：https://cnodejs.org/topic/581b0c4ebb9452c9052e7acb\n\t*七天学会NodeJS：http://nqdeng.github.io/7-days-nodejs/\n\n# 进阶\n## TypeScript\n\n* 中文网：https://www.tslang.cn/\n* TypeScript Handbook(中文版)：https://zhongsp.gitbooks.io/typescript-handbook/content/\n\n### ECMAScript\n* ECMAScript 5\n\t* W3C 规范镜像版: http://yanhaijing.com/es5/#null\n\t* 自学手稿版： http://es5.weijieblog.com/\n* ECMAScript 6 阮一峰：http://es6.ruanyifeng.com/\n\n### 正则表达式\n\n* 三十分钟入门：https://deerchao.net/tutorials/regex/regex.htm\n\n### 工程化\n\n* gulp 中文网：http://www.gulpjs.com.cn/\n* NPM 淘宝镜像:http://npm.taobao.org/\n* AppVeyor 自动部署：https://ci.appveyor.com/\n\n# 资源\n\n* 收藏夹：http://u-hey.com/20/126\n\n## 图片压缩\n\n* 腾讯ISUX前端智图：http://zhitu.isux.us/\n\n## 在线编程\n\nCODEPEN：https://codepen.io/\nJSFiddle：https://jsfiddle.net/\n\n## MarkDown 语法\n\n* MarkDown 中文：http://wowubuntu.com/markdown/index.html\n\n## 代码高亮\n\nHighlightjs：https://highlightjs.org/static/demo/\n\n## CDN 静态资源库\n\n* 360 前端静态资源库：https://cdn.baomitu.com/\n* Staticfile CDN：https://www.staticfile.org/\n* 又拍云：http://www.bootcdn.cn/\n\n# 前端团队\n\n* 阿里巴巴国际UED:http://www.aliued.com/\n* 淘宝前端团队（FED）:http://taobaofed.org/\n* 腾讯Alloy Team：http://www.alloyteam.com/\n* 腾讯ISUX：https://isux.tencent.com/\n* 百度FEX：http://fex.baidu.com/\n* 京东Aotu：https://aotu.io/\n* 360 奇舞：https://75team.com/","tags":["Web"],"categories":["其他"]},{"title":"函数作用域及块作用域","url":"%2Fpages%2F70cbbc9f%2F","content":"\n## 最小特权原则\n\n最小特权原则也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。\n\n### 函数封装\n\n将函数和变量包裹在一个外部包装函数的作用域中，使用这个作用域将这些具体的细节隐藏起来，实现函数的封装。\n1. 可以避免同名标识符之间的冲突，避免全局变量污染。\n2. 将具体内容私有化，防止外部以非预期的方式使用内部私有的内容。\n\n## 函数作用域\n\n函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。\n\n**函数声明:**\n```javascript\nfunction foo() {\n    for (let i = 0; i < 10; i++) {\n        console.log(i);\n    }\n}\n\nfoo();\n```\n\n**立即执行函数表达式：**\n```javascript\n(function foo() {\n    for (let i = 0; i < 10; i++) {\n        console.log(i);\n    }\n})();\n\n```\n\n区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。**如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。**\n\n函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。\n1. 函数声明中，foo 被绑定在所在的作用域中，可以在外部通过 foo() 来调用它。\n2. 函数表达式中，foo 被绑定在函数表达式自身的函数中，外部不能访问调用，只能在其(function foo(){...}) 中的`...`位置被访问。\n\n### 匿名函数表达式\n\n函数表达式可以匿名，而函数声明则不可以省略函数名。\n\n### 立即执行函数表达式（IIFE）\n\n立即执行函数表达式（Immediately Invoked Function Expression），将函数包含在一对（）中，成为一个函数表达式，在末尾加上另一对（）可以立即执行这个函数。\n第一个（）将函数变成表达式，第二个（） 执行了这个函数。\n\n#### IIFE 的两种写法\n\n1. 立即执行函数表达式：\n\n```javascript\n(function foo() {\n    for (let i = 0; i < 10; i++) {\n        console.log(i);\n    }\n})();\n\n```\n2. 另一种改进形式写法将调用的（）移到了用来包装的（）里面。\n\n```javascript\n(function foo() {\n    for (let i = 0; i < 10; i++) {\n        console.log(i);\n    }\n}());\n```\n\n两种写法功能上一样，凭个人喜好。\n\n#### IIFE 表达式的用法\n\n1. 匿名函数表达式\n\n```javascript\n(() => {\n    const a = 6;\n    console.log(a); // a\n})();\n```\n\n2. 将它当作**函数调用**，并传递参数进去\n\n```javascript\nconst name = 'haha';\n(function IIFE(name) {\n    console.log(name); // haha\n})(name);\n\n```\n\n3. 倒置代码的运行顺序，将需要运行的函数放在第二位， IIFE 执行之后，放在第二位的函数被当作参数传递进去。\n\n```javascript\nconst objA = {\n    name: 'haha',\n};\n\n(function IIFE(foo) {\n    foo(objA);\n}((obj) => {\n    const name = '3';\n    console.log(name); // 3\n    console.log(obj.name); // haha\n}));\n```\n第二部分为一个匿名函数，被当作一个参数 foo 传入到 IIFE 函数的第一部分。最后匿名函数调用执行，将一个全局对象 objA 传入当作 obj 的参数值。\n\n## 块作用域\n\n块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。\n\n块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。\n\n只想在 for 循环内部的上下文中使用 i，所以在 for 循环的头部使用 var 声明一个变量 i，但实际上 i 会被绑定在外部作用域（函数或全局）中，在全局范围内都有效。\n\n```javascript\nvar arr = [];\nfor (var i = 0; i < 10; i++) {\n  arr[i] = function() {\n    console.log(i);\n  };\n}\narr[6](); // 10\n\n```\nconsole.log(i) 内部的 i 指向全局的的 i，最后循环完毕后在执行 arr[6]()，这时全局的 i 的值为 10.\n\nES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。\n\n### Let\n\nlet 关键字可以将变量绑定到所在的任意作用域中（通常是 {  ..  } 内部）。换句话说，let 为其声明的变量隐式地了所在的块作用域。\n\n```javascript\nvar arr = [];\nfor (let i = 0; i < 10; i++) {\n  arr[i] = function () {\n    console.log(i);\n  };\n}\narr[6](); // 6\n```\n\n由 let 声明的 i，每次循环都在循环的内部重新生成了一次变量，\n\n```javascript\nvar arr = [];\nfor (let i = 0; i < 10; i++) {\n    let _i = i;\n  arr[i] = function () {\n    console.log(_i);\n  };\n}\narr[6](); // 6\n```\nfor 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\n\nlet声明的变量只在它所在的代码块有效。\n\n```javascript\n{\n    var a = 6;\n    let b = 9;\n}\n\nconsole.log(a); // 6\nconsole.log(b); // b is not defined\n```\n### 暂时性死区\n\n在代码块内，使用 let 命令声明变量，在声明之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）.\n\n```javascript\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n```\nES6明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n\n```javascript\nvar tmp = 6;\n\nif(true) {\n  tmp = 3; // ReferenceError\n  let tmp;\n}\n```\n\n","tags":["YouDon'tKnowJavaScript"],"categories":["JavaScript"]},{"title":"全局命名空间和模块","url":"%2Fpages%2Ff9a582e%2F","content":"\n## 全局命名空间\n\n库通常会在全局作用域中声明一个名字独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。\n\n例如：\n```javascript\nvar mylibrary = {\n    name: 'haha',\n    eat: (name) => {\n        console.log(`${name} is eating`);\n    }\n};\n```\n\n## 模块管理\n\n通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。\n\n用作用域的规则，强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。\n","tags":["YouDon'tKnowJavaScript"],"categories":["JavaScript"]},{"title":"作用域闭包","url":"%2Fpages%2F78f2b66e%2F","content":"## 闭包\n\nwiki 上对闭包的定义：\n闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），**是引用了自由变量的函数。**这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为**闭包是由函数和与其相关的引用环境组合而成的实体。**\n\n**自由变量的定义**：在 fn() 作用域中使用的变量 x，却没有在 fn() 作用域中声明（即在其他作用域中声明的），对于 foo() 作用域来说，x 就是一个自由变量。\n\n当函数**可以记住并访问所在的词法作用域**时，就产生了**闭包**，即使函数是在自己定义的词法作用域以外的地方执行。\n\n闭包使得函数在**定义时的词法作用域以外**的地方被调用时，函数**可以继续访问定义时的词法作用域**。\n\n在 JavaScript 中有垃圾回收器用来释放不再使用的内存空间，通过使用闭包可以阻止这件事情的发生，使得这个函数的内部作用域一直存活。\n\n在函数 foo() 内部定义了函数 bar()， bar() 引用了其父函数作用域的变量，对这个内部作用域的引用就叫作闭包。\n\n```javascript\nfunction foo() {\n    var a = 2;\n\n    function func() {\n        console.log(a);\n    }\n\n    bar(func);\n}\n\nfunction bar(fn) {\n    fn(); // 这就是闭包\n}\n\n```\n将 foo() 内部定义的func() 函数作为一个参数，传递给在全局作用域下定义的 bar(fn) 函数，从而达到访问 func() 词法作用域的目的。\n\n无论通过何种手段**将内部函数传递到所在的词法作用域以外**，它都会**持有对原始定义作用域的引用**，无论在何处**执行这个函数都会使用闭包**。\n\n\n","tags":["YouDon'tKnowJavaScript"],"categories":["JavaScript"]},{"title":"作用域以及 LHS 和 RHS 查询","url":"%2Fpages%2Fb917f198%2F","content":"## 作用域\n\n**1.** 作用域是一套规则，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，用于确定在何处以及如何查找变量（标识符），并实施一套非常严格的规则，用于确定当前执行的代码对这些标识符的访问权限。作用域就是函数或者变量能被访问到的范围。\n\n**2.** 作用域有两种工作模型：\n* 词法作用域(JavaScript)：词法作用域就是定义在词法阶段的作用域。\n* 动态作用域(Bash脚本)\n\n**3.** 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。例如：`window.a`\n\n这样可以访问到被局部同名变量所遮蔽的全局变量。\n\n## 执行上下文\n\n**执行上下文在运行时确定，词法作用域在定义时确定。**\n\n### 欺骗作用域\n\n无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数**被声明时所处的位置**决定。\n\nJavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在\n运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作\n用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。\n\n#### eval()函数欺骗\n\nJavaScript 中的 eval() 函数可以接受一个字符串为参数，并将传入的字符串视为好像在书写时就存在于程序中这个位置的 JavaScript 代码进行执行。例如：\n\n```javascript\nvar a = 66;\nfunction bar(str, b) {\n    eval(str);\n    console.log(a, b); // 55 10\n}\n\nbar('var a = 55;', 10);\n```\n使用 eval() 函数可以将代码以动态形式插入一个指定位置，如果 eval() 中所执行的代码包含一个或多个声明（函数或者变量），就会对词法作用域的环境进行修改，达到欺诈伪装的效果。\n\n在严格模式下，eval() 函数拥有这自己的词法作用域，其中的声明将无法修改作用域。\n\n这个函数的副作用是引擎无法在编译时对作用域查找进行优化，会导致代码运行变慢，不建议使用。\n\n## LHS 和 RHS查询\n### LHS 查询\n\n**对变量进行赋值操作，那么就会使用 LHS 查询。**\n\n当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，\n全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。\n\n严格模式禁止自动或隐式地创建全局变量。 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。\n\n### RHS 查询\n\n**查找获取某个变量的值，就会使用 RHS 查询。**\n\n如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。","tags":["YouDon'tKnowJavaScript"],"categories":["JavaScript"]},{"title":"js术语中英对照表","url":"%2Fpages%2F6ad0123c%2F","content":"## 编译相关\n\n* compile 编译\n* tokenizing 分词\n* lexing 词法分析\n* toekn 词法单元\n* parsing 解析/语法分析\n* Abstract Syntax Tree(AST) 抽象语法树\n* raw code 代码生成\n* LHS(Left-hand Side) 赋值操作左侧，进行赋值操作\n* RHS(Right-hand Side) 赋值操作非左侧，进行取值操作\n\n## 异常\n\n* ReferenceError 引用错误\n* TypeError 类型错误\n\n## 函数\n\nImmediately Invoked Function Expression(IIFE) 立即执行函数表达式\nTemporal dead zone(TDZ) 暂时性死区\nExecution context 执行上下文\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"包管理器 Yarn","url":"%2Fpages%2F522f484%2F","content":"# 包管理器 Yarn\n\n>Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具。\n\n## 常用命令\n* yarn和 yarn install ，这两个命令的效果是一样的，等同于npm install，使用这个命令会在该目录生成一个yarn.lock的文件。\n* yarn add koa，安装koa模块并更新package.json和yarn.lock文件，等同于npm install koa --save。也可以使用yarn global add koa，等同于npm install koa -g，将模块直接安装到全局环境变量里，方便使用。\n* yarn list，根据当前项目的package.json查看模块的依赖及版本。\n* yarn info koa，查看koa模块的详细信息，类似于npm view koa。\n* yarn init，初始化项目package.json文件，等同于npm init。\n* yarn run，运行package.json中的script。","tags":["Yarn"],"categories":["Nodejs"]},{"title":"JS基础基础","url":"%2Fpages%2Fd4c7d8e9%2F","content":"\n## JS简介\n\n* Netscape公司的Brendan Eich设计JS，只能运行在浏览器中。\n* Ryan Dahl于2009年设计node.js，JS可以在服务端运行。\n* JavaScript 是脚本语言。浏览器会在读取代码时，逐行地执行脚本代码。而传统编程语言，会在执行前对所有代码进行编译。\n* _proto_ 实现继承关系。\n* 对象名.prototype在原型对象层次优化子对象对公共方法的调用。\n* 语法糖使javascript贴近java语法。\n\n## 基础\n### 数据类型\n#### 字符串（String）\n* str.length; 查看一个字符串的长度。\n* str.charAt(index); 获取单个字符。\n* str.split(\"a\"); 指定从 a 处分割字符串为字符串数组。\n* str.slice(开始索引， 结束索引); 获取一个字符串中的一部分内容，字符串切片。\n* str[]; 通过索引获取单个字符。\n* str.indexOf('所选字符'); 获取字符串中单个或者多个字符索引，如果找不到成员，返回 -1\n* str.toLowerCase(); 将字符串转化为小写返回。\n* str.toUpperCase(); 将字符串转化为大写返回。\n```javascript\n// 字符串操作\nvar str = '东风无力百花残';\n// 获取字符串长度 a\nvar a = str.length;\n// 获取字符 '花' 的索引\nvar b = str.indexOf('花');\n// 通过索引获取字符 '百花'\nvar c = str.slice(b - 1, b + 1);\nconsole.log(\"字符串长度：\" + a + \"\\n花的索引：\" + b + \"\\n获取花字符：\" + c);\n```\n\n```javascript\n/* 将一个大小混写的人名，姓全部转换为大写，名除首字母外全部转换为小写。\n*/\n// 定义一个 name 字符串\nvar name = \"ALbERt EINstEin\";\nfunction nameChanger(name) {\n  // 定义 finaNmae 复制 name 内容\n let finaName = name;\n  // 以空格为参考，分割字符串为字符串数组\n  // names = [\"ALbERt\", \"EINstEin\"]\n  let names = name.split(\" \");\n  // slice(0， 1) 选择首字母转换为大写，slice(1) 选择后面的字符转换为小写\n  names[0] = names[0].slice(0, 1).toUpperCase() + names[0].slice(1).toLowerCase();\n  // 设置第二个数组元素全部为大写\n  names[1] = names[1].toUpperCase();\n  // 将数组中的所有元素转换为一个字符串\n  // 设定空格为分隔符\n  finaName = names.join(\" \");\n  console.log(finaName);\n}\nnameChanger(name);\n```\n#### 数组(Array)\n* splice(index, num, item1,.....,itemN); 用于插入、删除或替换数组的元素。\n  * index （必须） 删除/添加元素的开始下标。\n  * num （必须） 删除元素的数量。\n  * item （可选） 要添加的新元素。\n* pop(); 删除数组末尾的元素。\n* push(\"item\"); 添加元素到数组末尾。\n* shift(); 删除数组头部元素。\n* unshift(\"item\"); 添加元素到数组头部。\n\n#### 数字(Number) 所有数字以 64 位浮点数储存.\n* JavaScript 使用数字表示形式的 8 字节 IEEE 754 浮点标准来表示数字。  这意味着您可以编写最大为 1.79769x10308 和最小为 5x10-324 的数字。\n* 以零开头且后面的数字都小于 8， 会被识别为八进制数。\n* 0x 或 0X开头为十六进制数。\n* 八进制或者十六进制数字不能有小数部分。\n* JavaScript 区分正零和负零。\n\n#### 布尔(Boolean)\n* 可将任何表达式用作比较表达式。计算结果为 0、null、undefined 或空字符串的任何表达式被解释为 false。\n\n#### 对象(Object)\n* 确定对象属性是否存在，可使用 in 运算符：\n```javascript\n// 定义一个 people 对象\nvar people = {\n  name: 'xiaoming',\n  age: 12,\n};\n// 判断 people 对象中是否存在 name 属性\nif('name' in people) {\n  console.log('true');\n}\nelse {\n  console.log('flase');\n}\n// 输出 true\n```\n\n#### 日期(Date)\n#### 方法(function)\n* indexOf('目标', 开始位置 ); 获取数组成员索引，开始位置可省略不写。若成员不存在返回值为 -1。\n* splice(index, num); 删除指定索引 index 位置的数组成员，num 指删除数量。返回值为删除的数组。\n\n#### 空（Null）\n* 表示什么都没有，将变量赋值 null 可以清除变量的内容（不删除变量）。\n```javascript\n  var num = null; // 值为空 null\n  typeof num; //返回值为 object\n```\n\n#### 未定义（Undefined）\n* 变量的值未定义。可以将变量与 undefined 进行比较确定变量是否存在。\n* 也可以通过将变量的类型与字符串“undefined”进行比较确定其类型是否为 undefined。\n```javascript\n  var num;\n  typeof num; // 返回值为 undefined\n```\n**null 和 undefined 的值相等，类型不同。null 值的行为与数字 0 类似，而 undefined 的行为与特定值 NaN（非数字）类似。**\n\nJavaScript 拥有动态类型，相同的变量可用作不同的类型：\n```javascript\nvar x;               // 此时 x 为 undefined\nvar x = 5;           // 此时 x 为数字\nvar x = 'hello';      // 此时 x 为字符串\n```\n\n#### 强制转换\n* JavaScript 是一个弱类型的语言，其变量类型由其值的类型决定。\n* 字符串、数字和布尔值的强制转换规则：\n    * 如果添加一个数字和字符串，则该数字会强制转换为字符串。\n    * 如果添加一个布尔值和字符串，则该布尔值会强制转换为字符串。\n    * 如果添加一个数字和布尔值，则该布尔值会强制转换为数字。\n\n##### parseFloat\n将字符串转换为浮点数。\n`parseFloat(numString);` numString 参数是一个包含浮点数的字符串。函数返回一个等于 numString 中包含的数字的数值。如果 numString 的前缀无法解析为浮点数，则返回 NaN（非数字）。\n\n##### parseInt\n将字符串转为整数。\n`parseInt(numString, radix);`numString 参数是要转换为数字的字符串。radix(2~36) 为需要转成整数的进制。若没有指定基数：以\"0x\"或者\"0X\"开头, 则是 16 进制；0 开头为 8 进制或者 10 进制，具体由环境决定；其它默认是 10 进制。 函数将其第一个参数转换为字符串然后再解析它，解析成功返回一个进制指定的整数，反之返回 NaN。\n\n## 操作符\n操作符优先级;\n| 运算符                             | 说明                                                   |\n| ---------------------------------- | ------------------------------------------------------ |\n| .[ ] ( )                           | 字段访问、数组索引、函数调用和表达式分组               |\n| ++ -- - ~ ! delete new typeof void | 一元运算符、返回数据类型、对象创建、未定义的值         |\n| * / %                              | 相乘，相除，取模                                       |\n| + - +                              | 相加、相减、字符串串联                                 |\n| << >> >>>                          | 移位                                                   |\n| < <= > >= instanceof               | 小于、小于或等于、大于、大于或等于、是否为特定类的实例 |\n| == != === !==                      | 相等、不相等、全等，不全等                             |\n| &&                                 | 逻辑“与”                                             |\n| `||`                               | 逻辑“或”                                             |\n| ?:                                 | 三元条件运算                                           |\n| = OP=                              | 赋值、赋值运算（如 += 和 &=）                          |\n| ,                                  | 多个计算                                               |\n### 逻辑运算符\n==  **只比较两边的值，与类型无关。**当值相等时返回 true，\n===  **同时比较两边的类型和值**，只有当类型和值都相等时返回 true。\n\n!=  **只比较两边的类型，与值无关**，类型相同返回 true，类型不同返回 false\n!== **只要值或者类型有一个不相等**，返回 ture\n\n### 位运算符\n* 两个整数交换数值\n`a ^= b;\nb ^= a;\na ^= b;`\n```javascript\n// 位操作快速交换两个整数的值\nvar a = 10;\nvar b = 12;\na ^= b;\nb ^= a;\na ^= b;\nconsole.log('a is:' + a + '\\nb is:' + b); // a is:12 b is:10\n```\n## 函数\n> 函数也称为'全局方法'。\n### 箭头函数\n#### 常见错误\n* 错误1：使用箭头函数定义对象的方法\n* 错误2：在原型上使用箭头函数\n#### 适用场景\n* 箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在map、reduce、filter的回调函数定义中；\n* 不要在最外层定义箭头函数，因为在函数内部操作this会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将this控制在可见的范围内；\n* 如开头所述，箭头函数最吸引人的地方是简洁。在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。\n#### 副作用\n1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n4. 不可以使用yield命令，因此箭头函数不能用作Generator函数。\n### in 运算符\n判断某个属性是否属于这个对象。\n`'name' in obj`\n* 'name' 属性值\n*  obj 对象\n\n### instanceof 运算符\n返回值为布尔类型，判断一个对象是否为特定类的一个实例。\n`result = obj instanceof class`\n* result 返回值\n* obj 对象\n* class 特定类\n\n### 其它运算符\n#### typeof\n* 可以使用 typeof 操作符来检测变量的数据类型。`typeof 66  // 返回值为 number `。\n* 在JavaScript中，数组是一种特殊的对象类型。 typeof [1,2,3,4] 返回 object。\n\n\n### 单双引号\n* 同一种引号不能嵌套,最外层一般使用单引号，避免和 HTML 里面的冲突：\n\n```javascript\n//会报错误\n\"\"name\" + 18\"\n//正确的方式\n'\"name\" + 18'\n```\n### 模板字符串\n> 允许嵌入表达式的字符串。使用反引号（``）代替单引号或者双引号，中间包含特定语法（${表达式}）,表达式是任意 JavaScript 表达式（如变量或函数）。\n```javascript\n  `hello ${表达式}`;\n   `sun ${a + b}`\n```\n\n## 变量\n* JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。\n* 声明新变量时，可以使用关键词 \"new\" 来声明其类型。`var x = new String;`\n* 使用 let 和 var 关键字声明变量，let的作用域是块，而var的作用域是函数。\n* 如果把值直接赋给尚未声明的变量，该变量将被自动作为全局变量声明。\n* let 可以声明作用域被限制在块级中的变量、语句或者表达式。var声明的变量是全局或者整个函数块的。\n* let声明的变量只在其声明的块或子块中可用，这一点，与var相似。二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。\n* 在 HTML 中, 全局变量都是 window 对象: 所有数据变量都属于 window 对象。\n\n```javascript\nfunction varTest() {\n  var x = 1;\n  if (true) {\n    var x = 2;  // 同样的变量\n    console.log(x);  // 显示2\n  }\n  console.log(x);  // 显示2\n}\n\nfunction letTest() {\n  let x = 1;\n  if (true) {\n    let x = 2;  // 不同的变量\n    console.log(x);  // 显示2\n  }\n  console.log(x);  // 显示1\n```\n\n* 在程序或者函数的顶层，let并不会像var一样在全局对象上创造一个属性.\n\n```javascript\nvar x = 'global';\nlet y = 'global';\nconsole.log(this.x); // \"global\"\nconsole.log(this.y); // undefined\n```\n\n## JS 面向对象\n* javascript是基于原型的面向对象的语言，没有类的概念。\n\n### 创建对象\n\n  - JS中不用 class 创建对象\n  - 对象：属性加方法构成\n\n```javascript\n  //创建一个 people 对象，拥有 name 属性和 speak 方法\n  var people = {\n      country: \"CN\";\n      from: funcation(){\n          console.log(\"From\" + this.conuntry)\n      }\n  }；\n  people.from();\n  //由于对象并不和类关联， 我们可以随意地给这个对象增加属性\n  people.speak = \"Chinese\";\n  console.log(people.speak);\n  ```\n\n### 继承\n\n  - 继承就是让两个对象建立关联，\n  - 在 Javascript 中每个对象都有一个特殊的属性叫做__proto__， 你可以用这个属性去关联另外一个对象(原型)。\n\n```javascript\n    //定义一个american对象\n    var american = {\n      country: \"US\";\n      _proto_: people;//指向people对象\n    }；\n    //定义一个chinese对象\n    var chinese = {\n      country: \"CN\";\n      _proto_:people;//指向people对象\n    };\n    american.from();\n    chinese.from();\n  ```\n\n- american, chinese 的原型都是 people，当 from() 方法被调用时，先在自身的方法列表中寻找，找不到时再去原型中去寻找，如果原型中找不到，就去原型的原型中寻找，直到 Object 那里，如果还找不到，那就是方法未定义。这些对象通过_proto_建立了一个原型链。\n\n### 构造函数 原型\n* 将原型对象放入 Object.prototype 中，每次 new 新对象时，js会自动建立原型链。\n\n```javascript\n  function Student(name){\n    this.name = name;\n  }\n  Student.prototype = {\n    say: function(){\n      console.log(\"My name is\" + this.name);\n    }\n  }\n  //创建新对象，js自动构建原型链继承 say 方法\n  var xiaoming = new Student(\"xiaoming\");\n  var laowang = new Student(\"laowang\");\n\n  xiaoming.say();\n  laowang.say();\n  ```\n\n### 语法糖\n\n```javascript\n  class Student{\n    constructor(name){\n      this.name = name;\n    }\n    say(){\n      console.log(\"My name is\" + this.name);\n    }\n  }\n\n  var xiaoming = new Student(\"xiaoming\");\n  xiaoming.say();\n  ```\n### 闭包\n\n  ​\n\n## AJAX 异步调用\n\n* 异步的 JavaScript 和 XML\n* AJAX 是一种用于创建快速动态网页的技术。\n* 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n* 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。\n* 例如服务器返回下面的 XML 数据：\n\n```xml\n<book>\n    <isbn>978-7-229-03093-3</isbn>\n    <name>三体</name>\n    <author>刘慈欣</author>\n   <introduction>中国最牛的科幻书</introduction>\n   <price>38.00</price>\n</book>\n```\n\n* 上面的数据中，标签占去了大部分，数据比较臃肿。\n\n## JSON\n\n* JavaScript 对象表示法（JavaScript Object Notation）。\n* JSON 是存储和交换文本信息的语法。类似 XML。\n* JSON 比 XML 更小、更快，更易解析。\n* JSON.parse(); 解析一个JSON字符串，可选地转换生成的值及其属性，并返回值。\n* JSON.stringify(); 返回与指定值相对应的一个JSON字符串，可选地仅包含某些属性或以用户定义的方式替换属性值。\n\n```javascript\n//这种结构完全可以表达上面的xml 内容\nvar book = {\n\"isbn\": \"978-7-229-03093-3\",\n\"name\": \"三体\",\n \"author\": \"刘慈欣\",\n\"introduction\": \"中国最牛的科幻书\",\n\"price\": \"38.00\"\n }\n//JS语法还支持数组，可以表达多个对象\nvar books = [\n {\n\"isbn\": \"978-7-229-03093-3\",\n\"name\": \"三体\",\n\"author\": \"刘慈欣\",\n\"introduction\": \"中国最牛的科幻书\",\n\"price\": \"38.00\"\n },\n {\n\"isbn\": \"978-7-229-03094-1\",\n\"name\": \"我是一个线程\",\n\"author\": \"刘欣\",\n\"introduction\": \"一个线程的自述\",\n\"price\": \"0.0\"\n }\n```\n\n* books[0].name -->返回“三体\"\n* books[1].author -->返回“刘欣”\n","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"javascript DOM","url":"%2Fpages%2F218ff168%2F","content":"## 消息窗口\n\n* document.write(字符串或者变量或者 Html 标签); 直接在向 html 的输出流中写内容，直接在网页中输出容。\n* alert(字符串或变量); 弹出一个包含确定的消息对话框。\n![js-alert](https://i.loli.net/2017/10/26/59f1ff9e6f473.png)\n\n* confirm(stri); 弹出一个包含确定和取消的消息对话框。\n    * str 消息框显示的文本。\n    * 返回值为 Boolean 类型，通过返回值判断用户点击了什么按钮，确定为 true ，取消为 false。\n![js-confirm](https://i.loli.net/2017/10/26/59f1ffb53699b.png)\n\n* prompt(str1, str2) 弹出包含一个确定按钮、取消按钮与一个文本输入框的消息对话框。\n    * str1 消息框显示文本，不可修改。\n    * str2 文本框中的内容，可修改。\n    * 返回值：点击确定，文本框内容作为函数返回值。点击取消，返回 null。\n\n* open() 方法可以查找一个已经存在或者新建的浏览器窗口。\n    * window.open() 打开一个新窗口。\n```javascript\n    window.open([URL], [窗口名称], [窗口参数设置])\n    /* URL(可选参数):网页网址或路径，如果它的值是空字符串，那么窗口就不显示任何文档。\n    * 窗口名称(可选参数)：被打开窗口的名称。只能由字母，数字或下划线构成。\n    * _balnk:新窗口打开； _self:当前窗口打开； _top：框架网页中在上部窗口中显示目标网页；\n    * 相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。\n    */\n```\n    * 窗口参数 ：\n| 参数       | 值      | 含义                     |\n| ---------- | ------- | ------------------------ |\n| top        | Number  | 窗口顶部离开屏幕顶部像素 |\n| left       | Number  | 窗口顶部离开屏幕顶部像素 |\n| width      | Number  | 窗口宽度                 |\n| height     | Number  | 窗口高度                 |\n| menubar    | yes，no | 窗口菜单                 |\n| toolbar    | yes，no | 窗口工具栏               |\n| scrollbars | yes，no | 窗口滚动条               |\n| status     | yes，no | 窗口状态栏               |\n\n* close() 关闭窗口\n\n```javascript\n    window.close(); // 关闭本窗口\n    [对象窗口].close() // 关闭对象窗口\n```\n\n## JS HTML DOM\n> 浏览器从服务器取到HTML网页以后， 会展示成页面让你看， 但是他的内部其实会把HTML组织成一个树给JS,这个树可以称为DOM。 例如这个页面：\n\n* 浏览器从服务器取到HTML网页以后， 会展示成页面让你看， 但是他的内部其实会把HTML组织成一个树给JS,这个树可以称为DOM。 例如这个页面：\n\n```html\n<html>\n <head>\n   <title>Sample Page</title>\n </head>\n <body>\n   <p>hello world!</p>\n </body>\n</html>\n```\n![full-html-tree](https://i.loli.net/2017/10/26/59f1ffc7e1cb1.png)\n\n通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML:\n* JavaScript 能够改变页面中的所有 HTML 元素\n* JavaScript 能够改变页面中的所有 HTML 属性\n* JavaScript 能够改变页面中的所有 CSS 样式\n* JavaScript 能够对页面中的所有事件做出反应\n\n### 通过 JavaScript 操作作 HTML 元素\n> JS可以定位到DOM树中任意一个节点， 然后对这个节点进行操作， 例如隐藏节点、显示节点、改变颜色、获得文本的值， 改变文本的值，添加一个响应点击事件的函数等。\n\n1. 查找 HTML 元素\n* 通过 id 找到 HTML 元素：`var x = document.getElementById(\"ID\");\n* 通过标签名找到 HTML 元素：`var x = document.getElementById(\"ID\");\nvar y = x.getElementsByTagName(\"p\");`\n* 通过类名找到 HTML 元素\n* stringObject.match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\n\n2. 改变元素内容\n* document.getElementById(\"ID\").innerHTML=\"Hello\"; // 改变内容\n* isNaN(x); // x 是否为数字\n* document.write(\"写入内容\"), // 向文档输出写内容\n\n3. 改变元素样式\n* document.getElementById(\"ID\").style.color=\"#ff0000\";   // 改变样式\n* document.getElementById(\"ID\").style.visibility=\"hidden\"; // 隐藏元素\n* document.getElementById(\"ID\").style.visibility=\"visible\" // 显示元素\n\n## DOM 事件\n### HTML 常见事件\n* 当用户点击鼠标时\n* 当网页已加载时\n* 当图像已加载时\n* 当鼠标移动到元素上时\n* 当输入字段被改变时\n* 当提交 HTML 表单时\n* 当用户触发按键时\n\n| 事件                      | 含义                                                                               |\n| ------------------------- | ---------------------------------------------------------------------------------- |\n| onclick                   | 元素被点击时，调用绑定函数                                                         |\n| onload 和 onunload        | 在用户进入或离开页面时被触发，用于检测访问者的浏览器类型和浏览器版本，处理 cookie  |\n| onmouseover 和 onmouseout | 将鼠标移至 HTML 元素上方或移出元素时触发                                            |\n| onchange                  | 当域内的内容被改变时，执行绑定函数。例如：向输入框内输入小写，完成后自动转换为大写 |\n| onmousedown 和 onmouseup  | 按下和释放鼠标，触发事件                                                            |\n| onfocus 和 onblur         | 获得焦点或者失去焦点时，触发事件。例如：向文本框输入时，改变其背景颜色             |\n\n### 绑定方式\n1. js 中绑定\n```javascript\n//  必须是一个函数的引用或函数名，而不是函数调用\n// 例如：foo(); 在这里将无效\ndocument.getElementById(\"ID\").onclick = foo;\n```\n2. html 中绑定\n ```html\nonclick=\"foo()\"\n```","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"html基础","url":"%2Fpages%2F1a147173%2F","content":"\n## 完整 HTML 树\n\n![DOM](https://i.loli.net/2017/10/26/59f1ff406e5f5.png)\n* 相关的 CSS 文件（针对样式）：\n\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n```\n\n* 相关的 JavaScript 文件（更改渲染和行为的多用途脚本）：\n\n```html\n<script src=\"myjavascripts.js\"></script>\n```\n\n* 粗体斜体\n\n```html\n<!-- 推荐使用<strong>进行加粗  -->\n <strong>粗体</strong>\n<!-- 推荐使用<em>进行斜体显示  -->\n<em>斜体</em>\n```\n\n* `<sup>` 标签定义上标文本。\n* `<sub>` 标签定义下标文本。\n\n\n","tags":["HTML"],"categories":["HTML"]},{"title":"git基础","url":"%2Fpages%2F9891ebc8%2F","content":"\n## git 基础命令\n### git 全局配置\n\n```\ngit config —global\tuser.name \"roojay\"\ngit\tconfig —global\tuser.email \"roojay520@gmail.com\"\n```\n\n### 创建文件夹 test\n```\nmkdir test\n```\n### 切换到 test 文件夹\n```\n cd test\n```\n### 新建 readme.md 文件\n```\n touch readme.md\n```\n\n### 初始化仓库\n```\n git init\n```\n### 查看仓库信息\n```\n git status\n```\n### 添加 readme.md 到缓存区\n```\n git add readme.md\n```\n### 将 readme.md 移除缓存区\n```\n git rm\t--cached readme.md\n```\n### 删除 readme.md 文件\n\n```\n  rm readme.md\n```\n\n### 删除文件 test 文件夹\n\n```\n rm -r test\n```\n### 提交文件到本地仓库\n```\n git commit\t-m 'first commit' //m 后面的 'fisrst commit' 表示提交信息\n```\n### 查看操作日志\n```\ngit\tlog\n```\n## branch 操作\n### 查看本地分支\n\n    git branch\n### 查看远程分支\n\n```\ngit branch -r\n```\n\n### 创建新分支 test\n\n    git\tbranch test\n### 切换分支\n\n    git\tcheckout test\n\n### 快速创建加切换\n\n    git\tcheckout -b test\n### 删除本地分支\n    git\tbranch\t-d\n    //强制删除本地分支\n    git branch -D test\n### 删除远程分支\n\n```\ngit push origin:testA\n```\n### 远程分支迁至本地\n\n```\ngit checkout testA origin/testA\n```\n\n### 版本标签\n```\ngit\ttag //查看版本记录\ngit tag v1.0.0 //创建版本 v1.0.0 标签\ngit checkout v1.0.0 //切换到v1.0.0 版本状态\n```\n## 提交代码到 GitHub\n### 1.生成 SSH\n```\nssh-keygen -t rsa\n```\n> 执行完以上命令后，在 C:/Users/Username/.ssh 文件下生成两个文件\tid_rsa（密钥）\t和\tid_rsa.pub（公钥）\n\n### 2.GitHub 添加 SSH key\n\n>  将 id_rsa.pub 的内容添加到\tGitHub： Setting→SSH keys and GPG keys→New SSH key\n>  输入\t`ssh -T git@github.com`测试是否添加成功\n\n### 3. Push 推送\n```\n//将本地代码推到远程 master 分支\ngit push origin master\n```\n### 4. Pull 拉取\n\n```\n//将远程 master 分支的代码拉取到本地\ngit pull origin master\n```\n### 5. 提交代码\n```\n//clone 自己的项目\ngit\tclone git@github.com:roojay520/test.git\n//修改 test 项目代码\n//commit 文件\ngit add change.md\ngit commit -m 'change file'\n//推送到 GitHub\ngit\tpush origin\tmaster\n```\n### 6. 关联本地已有项目\n> 假如我们需要把本地已有的 test1 项目的所有代码提交到 GitHub 上的 test\t项目。\n\n```\n//将本地 test1 项目与远程 test 项目关联\ngit\tremote add origin git@github.com:roojay520/test.git\n//其中 orgin 是远程仓库的名字\n//查看当前项目的远程仓库\ngit\tremote -v\n//向远程仓库提交代码\ngit push origin\tmaster\n```\n## git 进阶\n\n## 版本回退\n\n* 在Git中，用`HEAD`表示当前版本，上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。\n\n* 使用`git reflog`用来查看命令历史，或者使用`git log`查看提交 log，找到提交的 ` commit id`。\n\n* 使用`git reset`命令进行版本回退。\n\n  ```\n  //这个 HEAD 可以是具体的 commit id\n  git reset --hard HEAD^\n  ```\n\n## 常用配置\n### 用户配置\n> 全局设置用户名和用户邮箱\n> user.name 用户名； user.email 用户邮箱\n```\ngit\tconfig --global\tuser.name \"roojay\"\ngit\tconfig --global user.email \"roojay520@gmail.com\"\n```\n> 如果单独的某一个项目想要用特定的邮箱，切换到你的项目，以码把\t--global 参数去除，执行一遍。\n```\ngit\tconfig user.name \"roojay\"\ngit\tconfig user.email \"roojay520@gmail.com\"\n```\n### 快捷配置 alias\n>为命令设置别名\n```\n//切换 ck\ngit config --global alias.ck checkout #别名\n//提交 cm\ngit config --global alias.cm commit\n//查看信息 st\ngit config --global alias.st status\n//分支 br\ngit config --global alias.br branch\n```\n> 组合命令\n\n```\n//推送 psm\ngit config --global alias.psm 'push origin master'\n//拉取 plm\ngit config --global alias.plm 'pull origin master'\n```\n\n```\n//个性日志输出 lg\ngit config --global alias.lg \"log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative\"\n//设置个性日志输出\ngit log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative\n```\n\n## 合并分支\n> rebase\t跟 merge\t的区别可以理解成有两个书架，需要把两个书架的书整理到一起去，第一种做法是\tmerge\t，直接腾出一块地方把另一个书架的书全部放进去，这种做法你可以知道哪些书是来自另一个书架的；第二种做法就是 rebase\t，他会把两个书架的书先进行比较，按照购书的时间来给他重新排序，然后重新放置好，这样做的好处就是合并之后的书架看起来很有逻辑，但是你很难清晰的知道哪些书来自哪个书架的。\n\n### merge 暴力合并\n> 在 testA 分支开发完了一个功能，合并到主分支\tmaster\t上去\n```\ngit checkout master\ngit merge testA\n```\n\n### rebase 比较合并\n\n```\ngit checkout master\ngit rebase testA\n```\n","tags":["Git"],"categories":["Git"]},{"title":"for-in和for-of","url":"%2Fpages%2Ff5b5d35a%2F","content":"\n## for-in\n> `for-in`循环遍历的是对象的属性名称,可以将一个对象的属性循环遍历出来。\n```javascript\nvar obj = {\n    name: 'XiaoMing',\n    age: 22,\n    sex: 'man'\n};\nfor(let key in obj){\n    console.log(key); // 'name' 'age' 'sex'\n}\n```\n数组也是对象，`for-in`可以直接循环遍历出`Array`的索引，索引类型为 String 而不是 Number。\n```javascript\nvar array = ['a', 'b', 'c'];\nfor(let i in array){\n    console.log(i); // 索引'0' '1' '2'\n}\n```","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"arguments和rest","url":"%2Fpages%2Fe5332c52%2F","content":"## arguments 参数\n> 只在函数内部起作用，指向当前函数调用者传入的所有参数。\n\n```javascript\nvar bar = (x) => {\n    console.log(x); // a\n    for(let i = 0; i < arguments.length; i++){\n        console.log(arguments[i]); // 根据参数索引打印参数\n    }\n};\nbar('a', 'b', 'c');\n```\n\n* 利用`arguments`可以获得调用者传入的所有参数。\n* `arguments`常用于判断传入参数个数。\n\n## rest 不定参数\n> JS 允许函数接收任意个参数，当参数个数不确定的情况下可以使用不定参数。\n```javascript\n\"use strict\"; // 严格模式\n// 接受任意个参数返回它们的和\nfunction sum(...rest) { // 不定参数写在参数最后，前面使用 ... 标识\n  let result = 0;\n  for (let i of rest) { // rest 是一个数组实例\n      result += i;\n  }\n  console.log(result);\n}\nsum(1, 2, 3, 4); // 传入参数\n```\n不定参数写在参数最后，传入参数先绑定已有的参数，多余的参数以数组形式存入不定参数。","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Flex布局","url":"%2Fpages%2Fab688311%2F","content":"# Flex 布局\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes)\n* Flex 是 Flexible Box 的缩写，意为“弹性布局”，为盒模型提供灵活的布局方式。\n* 盒子中的子元素可以在各个方向上进行布局，并且能以弹性尺寸来适应显示空间。\n* 弹性容器的每个子元素都称为弹性项目。弹性容器直接包含的文本将被包覆成匿名弹性单元。\n* 元素的显示顺序可以与它们在源代码中的顺序无关。\n\n\n## 基础\n\n* flex 布局包括一个水平 main axis 和一个垂直 cross axis\n\n![](https://mdn.mozillademos.org/files/12998/flexbox.png)\n\n* 通过设置 display 的值启用 flex\n* 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。\n\n```css\n\t.box-flex{\n\t\tdisplay： -ms-flex；\n\t    display: -webkit-flex;\n\t    display: flex;\n\t}\n\t.box-inline-flex{\n\t\tdisplay: -ms-inline-flex;\n\t    display: -webkit-inline-flex;\n\t\tdisplay: inline-flex;\n\t}\n```\n\n## flex 属性\n\n* flex-direction：确立主轴。\n* justify-content：定义了在当前行上，弹性项目沿主轴如何排布。\n* align-items：定义了在当前行上，弹性项目沿侧轴默认如何排布。\n* align-self：定义了单个弹性项目在侧轴上应当如何对齐，这个定义会覆盖由 align-items 所确立的默认值。\n\n### flex-direction（主轴方向）\n![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png)\n> flex-direction 决定主轴方向（项目排列方向），包括四个值。\n* row（默认值）：主轴为水平方向，起点在左端。\n* row-reverse：主轴为水平方向，起点在右端。\n* column：主轴为垂直方向，起点在上沿。\n* column-reverse：主轴为垂直方向，起点在下沿。\n\n### flex-wrap（换行控制）\n![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png)\n> 控制一条轴上放不下子项目该如何换行。\n\n* nowrap（默认值）：不换行\n* wrap：换行，第一行在上。\n* wrap-reverse：换行，第一行在下。\n\n### justify-content（主轴排列方式）\n![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png)\n* flex-start：从行首起始位置开始排列。\n* flex-end：从行尾位置开始排列。\n* center：居中排列。\n* space-between：均匀排列每个元素\n首个元素放置于起点，末尾元素放置于终点。\n* space-around：均匀排列每个元素\n每个元素周围分配相同的空间。\n\n### align-items(侧轴排列方式)\n![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)\n\n* flex-start：元素向侧轴起点对齐。\n* flex-end：元素向侧轴终点对齐。\n* center：元素在侧轴居中。如果元素在侧轴上的高度高于其容器，那么在两个方向上溢出距离相同。\n* baseline: 项目的第一行文字的基线对齐。\n* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n### align-conten（多轴线对齐方式）\n\n> align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)\n* flex-start：所有行从垂直轴起点开始填充。第一行的垂直轴起点边和容器的垂直轴起点边对齐。接下来的每一行紧跟前一行。\n* flex-end：所有行从垂直轴末尾开始填充。最后一行的垂直轴终点和容器的垂直轴终点对齐。同时所有后续行与前一个对齐。\n* center：所有行朝向容器的中心填充。每行互相紧挨，相对于容器居中对齐。容器的垂直轴起点边和第一行的距离相等于容器的垂直轴终点边和最后一行的距离。\n* space-between：所有行在容器中平均分布。相邻两行间距相等。容器的垂直轴起点边和终点边分别与第一行和最后一行的边对齐。\n* space-around：所有行在容器中平均分布，相邻两行间距相等。容器的垂直轴起点边和终点边分别与第一行和最后一行的距离是相邻两行间距的一半。\n* stretch：拉伸所有行来填满剩余空间。剩余空间平均的分配给每一行。\n\n## 子项目属性\n\n* order：定义项目的排列顺序。数值越小，排列越靠前，默认为 0。\n![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png)\n* flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png)\n* flex-shrink：定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。属性为 0，项目不缩小，负值对该属性无效。\n![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)\n* flex-basis：定义项目在主轴所占据的基本空间，默认值 auto，即项目本来的大小。\n* flex：是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n* align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png)","tags":["CSS"],"categories":["CSS"]},{"title":"css布局","url":"%2Fpages%2F5a252ba9%2F","content":"\n# CSS 基础布局\n\n## 清除浮动\n简单的 Micro clearfix 方法清除浮动，原文链接:http://nicolasgallagher.com/micro-clearfix-hack/\n```scss\n@mixin clearfix {\n    &::before, &::after{\n        content: \" \";\n        display: flex;\n    }\n    &::after {\n        clear: both;\n    }\n}\n```\n## 三栏式布局\n\n> 两边侧栏固定宽度，中间栏宽度自适应，并且中间栏要在放在文档流前面以优先渲染。\n> 其父元素的高度始终是由三栏中高度最高的元素确定。\n\n### 圣杯布局\n\n> 来源于 Matthew Levine 于 2006 年发表在 Alistapart 上的一篇文章。[原文链接](https://alistapart.com/article/holygrail)\n\n```html\n<div class=\"container\">\n    <div class=\"box mid\"></div>\n    <div class=\"box left\"></div>\n    <div class=\"box right\"></div>\n</div>\n```\n\n1. 设置`box-mid` `box-left` `box-right` 三者向左浮动。\n2. 设置`box-mid`宽度为 100%。\n3. 设置负边距，`box-left`设置负左边距为 100%，`box-right`设置负左边距为负的自身宽度。\n4. 设置`container`的`padding`值，给`box-left`和`box-right`留出空间。\n5. 设置`left`和`right`为相对定位(position: relative).\n6. 设置`box-left`的`left`值为负的`box-left`宽度，`box-right`的`right`值为负的`right`宽度。\n\nQ:当面板的`mid`部分比两边的子面板宽度小的时候，布局会乱掉。\nA:为`body`设置一个最小宽度。`body{min-width:700px;}`\n\n### 淘宝双飞翼布局\n\n> 淘宝双飞翼布局是一个经典的三栏式布局，\n","tags":["CSS"],"categories":["CSS"]},{"title":"css和响应式","url":"%2Fpages%2F343902f6%2F","content":"\n# css框架\n## Bootstrap 框架\n> Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。\nhttp://www.runoob.com/bootstrap/bootstrap-tutorial.html\n\n* 在 html head 开头引入下面代码：\n\n```html\n<head>\n    <meta charset=\"UTF-8\">\n    <!--  兼容古老的 IE -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <!-- 响应式适应 ，width 属性控制设备的宽度显示， initial-scale=1确保网页加载时，以 1:1 的比例呈现，不会有任何的缩放，user-scalable=no 可以禁用其缩放（zooming）功能-->\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\">\n    <!-- CSS 样式重置 -->\n    <link href=\"https://cdn.bootcss.com/normalize/7.0.0/normalize.min.css\" rel=\"stylesheet\">\n    <!-- 引入 Bootstrap css 压缩文件-->\n    <link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n    <!-- 引入自己 css 的文件 -->\n    <link rel=\"stylesheet\" href=\"../style/task_1.css\">\n    <title>Test</title>\n</head>\n```\n\n## 响应式设计\n\n> 根据不同像素屏幕，展示不同大小页面。\n\n`!important` 为开发者提供了一个增加样式权重的方法。!important是对整条样式的声明，包括这个样式的属性和属性值。\n\n**### 媒体查询**\n\n```css\n@media only screen and (max-width: 300px) {\n    p {\n        background-color: red;\n    }\n}\n```\n\n* only 兼容旧式浏览器。\n* screen 表示这个媒体查询适用于所有屏幕。\n* and 后面跟条件。\n* **一般个@media样式要放在css样式表的最下面，不然会被相同样式覆盖。**\n\n### CSS 样式重置\n\n* 不同的浏览器在对于CSS没有定义的一些样式属性是不一样的\n* 比如没有在自己的CSS里面规定超链接有没有下划线的时候，有些浏览器有，有些浏览器没有。\n* 再比如有一些浏览器规定的超链接默认颜色是蓝色，有一些又是黑色。\n* 而这个CSS的功能就是对几乎所有的默认样式进行重置，让所有的浏览器上对于未定义的样式浏览效果达到一致。\n\n**使用方法：**\n\n```html\n<!-- 在自己的样式表前面引入以下 Normalize.css 360cdn 链接地址-->\n<link href=\"https://lib.baomitu.com/normalize/7.0.0/normalize.min.css\" rel=\"stylesheet\">\n```\n\n### 网格设计\n\n* 大部分网页采用 12 columns 设计，可以很好的划分为2，3，4等份。\n\n\n## 文章字体\n\n* segmentfault\n```css\nfont-family: -apple-system,\"Helvetica Neue\",Helvetica,Arial,\"PingFang SC\",\"Hiragino Sans GB\",\"WenQuanYi Micro Hei\",\"Microsoft Yahei\",sans-serif;\n\nfont-size: 14px;\n```\n\n* 知乎\n```css\nfont-family: Helvetica Neue,Helvetica,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Noto Sans CJK SC,WenQuanYi Micro Hei,Arial,sans-serif;\nfont-size: 15px;\n```\n\n## 颜色\n\n导航栏 #243d4c\n\n背景 #eee\n#f5f5f5\n#f8f8f8\n#ffffff\n\n按钮 #02b3e4\n#148bb1\n#2D78BA\n\n边框阴影\n```css\n.ss::before, .clss::before {\n    bottom: 0;\n    box-shadow: 0 -1px 0 #e0e0e0, 0 0 2px rgba(0,0,0,.12), 0 2px 4px rgba(0,0,0,.24);\n    content: '';\n    display: block;\n    left: 0;\n    pointer-events: none;\n    position: absolute;\n    right: 0;\n    top: 0;\n}\n```","tags":["CSS"],"categories":["CSS"]},{"title":"button常用设置","url":"%2Fpages%2F91b6115c%2F","content":"\n## 鼠标样式\n\ncursor：定网页浏览时用户鼠标指针的样式。\n\ncursor：pointer； 设定鼠标的形状为一只伸出食指的手，这也是绝大多数浏览器里面鼠标停留在网页链接上方时候的样式。\ndefault 箭头。\ncrosshair 十字\nprogress 沙漏\n\n## 按钮颜色\n\n平时的状态：\n```css\n.btn {\n    // 未按下时的背景颜色\n    background: ##02b3e4;\n    // 边框圆角\n    border-radius: 4px;\n    // 去掉边框\n    border: none\n    // 边缘阴影\n    box-shadow: 12px 15px 20px rgba(0, 0, 0, 0.1);\n    // 字体颜色\n    color: ##fff;\n    // 显示方式\n    display: inline-block;\n    // 字体\n    font-family: 'Open Sans', sans-serif;\n    font-size: 12px;\n    font-weight: 600;\n    // 字间距\n    letter-spacing: 0.165em;\n    // 超出隐藏\n    overflow: hidden;\n    // 设置渐变效果\n    transition: 0.2s box-shadow ease-in-out, 0.2s background-color ease-in-out, 0.2s border-color ease-in-out;\n}\n// 鼠标放上去时的颜色\n.btn:hover:not(:disabled) { background: ##148bb1;}\n```\n## 字体抗锯齿 -webkit-font-smoothing有\n> CSS3中用于webkit引擎(如chrome)中设置字体的抗锯齿或者说光滑度的属性。\n\n* none ------ 对低像素的文本比较好\n* subpixel-antialiased ------默认值\n* antialiased ------抗锯齿很好\n\n## 文本溢出 text-overflow\n> text-overflow 属性规定当文本溢出包含元素时发生的事情。\n* clip\t修剪文本。\n  * ellipsis显示省略符号来代表被修剪的文本。\n  * string使用给定的字符串来代表被修剪的文本。\n\n## 文本转换 text-transform\n> 转换不同元素中的文本。\n\n* none\t默认。定义带有小写字母和大写字母的标准的文本。\n  * capitalize文本中的每个单词以大写字母开头。\n  * uppercase定义仅有大写字母。\n  * lowercase定义无大写字母，仅有小写字母。\n  * inherit规定应该从父元素继承 text-transform 属性的值。\n\n## 元素变形过渡效果 transition\n> 设置元素渐变过渡，transition: property duration timing-function delay;需要加浏览器前缀。设置多个元素效果时用逗号隔开。\n> http://www.w3school.com.cn/cssref/pr_transition.asp\n\n* transition-property\t规定设置过渡效果的 CSS 属性的名称。\n  * transition-duration规定完成过渡效果需要多少秒或毫秒。\n  * transition-timing-function规定速度效果的速度曲线。（http://www.w3school.com.cn/tiy/t.asp?f=css3_transition-timing-function2）\n  * transition-delay定义过渡效果何时开始，过渡之前需要等待的实践。\n\n**速度曲线设置**\n* linear\t规定以相同速度开始至结束的过渡效果。\n  * ease规定慢速开始，然后变快，然后慢速结束的过渡效果。\n  * ease-in规定以慢速开始的过渡效果。\n  * ease-out规定以慢速结束的过渡效果。\n  * ease-in-out规定以慢速开始和结束的过渡效果。\n\n## 段落文本换行 white-space\n> white-space 属性设置如何处理元素内的空白。\n> http://www.w3school.com.cn/cssref/pr_text_white-space.asp\n\n* normal\t默认。空白会被浏览器忽略。\n  * pre空白会被浏览器保留。其行为方式类似 HTML 中的 <pre> 标签。\n  * nowrap文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。\n  * pre-wrap保留空白符序列，但是正常地进行换行。\n  * pre-line合并空白符序列，但是保留换行符。\n  * inherit规定应该从父元素继承 white-space 属性的值","tags":["CSS"],"categories":["CSS"]},{"title":"内部类","url":"%2Fpages%2F9bc01b38%2F","content":"\n* 内部类：一个类定义在另一个类的里面。\n\n#### 示例： ####\n>\n```java\nclass A{\n\tclass B{\n\t}\n}\n```\nB这个类被称之为A的内部类。\n编译之后生成A.class和A$B.class。\n内部类可以随意使用外部类的成员变量。\n\n# 内部类的使用方法 #\n#### 示例： ####\n```java\nclass A{\n\tint i;\n\tclass B{\n\t\tint j;\n\t\tint funB(){\n\t\t\tint result = i + j;\n\t\t\tSystem.out.println(result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nclass Test{\n\tpublic static void main(String args[]){\n\t\tA a = new A();\n\n\t\tA.B b = a.new B();\n\n\t\ta.i = 5;\n\t\tb.j = 6;\n\t\tb.funB();\n\t}\n}\n```\n\n# 匿名内部类的使用方法 #\n* 匿名内部类：没有名字的内部类。\n\n#### 示例： ####\n```java\ninterface A{\n\tpublic void doSth();\n}\nclass B{\n\tpublic void fun(A a){\n\t\tSystem.out.println(\"B类的fun函数\");\n\t\ta.doSth();\n\t}\n}\npublic class Test{\n\tpublic static void main(String args[]){\n\t\tB b = new B();\n\t\tb.fun(new A(){\n\t\t\tpublic void doSth(){\n\t\t\t\tSystem.out.println(\"匿名内部类\");\n\t\t\t}\n\t\t});\n\t}\n}\n```","tags":["Java"],"categories":["Java"]},{"title":"编译原理","url":"%2Fpages%2F118b8ca3%2F","content":"> 尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门**编译语言**。任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。但与传统的编译语言不同，它**不是提前编译**的，编译结果也**不能在分布式系统中进行移植**。\n\n## 编译三步骤\n\n**1.** 分词/词法分析（Tokenizing/Lexing）\n将字符串分解成编程语言所能识别的代码块，这些代码块被称为**词法单元（token）**。\n\n如果词法单元生成器在判断一个字符是一个独立的词法单元还是其他词法单元的一部分时（是否依赖于其他词法单元），调用的是**有状态**的解析规则，那么这个过程就被称为**词法分析**。\n\n**2.** 解析/语法分析（Parsing）\n将**词法单元流（数组）**转换成一个逐级嵌套结构的树“**抽象语法树”**（Abstract Syntax Tree，AST）。拥有一个顶级节点，以及连续的子节点。类似于 DOM树？\n\n**3.** 代码生成\n将抽象语法树转换为引擎可识别执行的代码。例如：var a = 2；\n第一步：创建一个叫做 a 的变量（分配内存，确定储存地址空间等）。\n第二步：运行时引擎会在作用域中查找该变量（LHS），找到之后将 2 这个值储存到 a 中。","tags":["YouDon'tKnowJavaScript"]},{"title":"JS转换字符串单词首字母大写","url":"%2Fpages%2Fe11bdebd%2F","content":"\n代码如下:\n```javascript\nconst string = 'to young, too simple.';\nconst toUp = str => str.split(' ').map(item => item.charAt(0).toLocaleUpperCase() + item.slice(1)).join(' ');\ntoUp(string);\n```","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"VSCode 配置 ESLint + Airbnb + vue","url":"%2Fpages%2F3bcc390e%2F","content":"\n## 基本环境\n\nWin 10 v1709\nNodejs v8.70\nVScode v1.17.2\n\n## VSCode 安装 ESLint 扩展\n\n打开 VSCode 搜索 ESLint 扩展安装\n\n## NPM 安装 ESLint\n\n1. 全局安装（推荐）:\n\n  `npm install eslint -g`\n\n2. 项目根目录本地安装：\n\n  `npm install eslint --save-dev`\n\n## 1. 自定义配置规则\n\n1. 全局配置\n在当前用户根目录下执行 `eslint --init`,根据个人爱好选择生成配置文件 `.eslintrc.json`\n例如：`windows\\user\\username`\n\n2. 项目根目录配置：\n在当前用户根目录下执行 `eslint --init`，根据个人爱好选择生成配置文件\n\nps：具体配置参考：http://eslint.cn/docs/user-guide/configuring\n\n## 2. 使用 eslint-config-airbnb 标准规则\n\n1. 查看 Airbnb 标准依赖插件版本：\n\n  `npm info \"eslint-config-airbnb@latest\" peerDependencies`\n\n例如：本次的 plugins 的版本要求:\n\n```\n{  eslint: '^4.9.0',\n  'eslint-plugin-import': '^2.7.0',\n  'eslint-plugin-jsx-a11y': '^6.0.2',\n  'eslint-plugin-react': '^7.4.0'\n}\n```\n2. 安装对应版本的插件:\n\n   `npm install eslint-config-airbnb eslint@^#.#.# eslint-plugin-jsx-a11y@^#.#.# eslint-plugin-import@^#.#.# eslint-plugin-react@^#.#.# -g`\n\n3. 更改配置文件 `.eslintrc.json` 如下：\n\n```json\n{\n    // 要启用的环境\n    \"env\": {\n        \"browser\": true,\n        \"node\": true,\n        \"commonjs\": true,\n        \"es6\": true,\n        \"jquery\": true\n    },\n    // 启用 airbnb 规则\n    \"extends\": \"airbnb\",\n    // 使用语言及版本\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\"\n    },\n    // 个人自定义规则\n    \"rules\": {\n        \"no-console\":\"off\",\n        \"no-plusplus\":\"off\"\n    }\n}\n```\n\n## ESLint 支持 Vue 单文件组件\n\n1. 安装 eslint-plugin-html 插件\n\n`npm install eslint-plugin-html -g`\n\n2. 在 VSCode 设置设置中添加如下配置：\n```json\n     // ESLint 配置\n    \"eslint.enable\": true,\n    // nodejs 路径， windows 路径使用双 \\\\ 进行转义\n    \"eslint.nodePath\": \"C:\\\\Dev\\\\nodejs\",\n    // 启用 eslint-plugin-html 插件\n    \"eslint.options\": {\n        \"plugins\": [\"html\"]\n    },\n    \"eslint.validate\": [\n        \"javascript\",\n        \"javascriptreact\",\n        // 启用 html 和 vue 中 ESLint 验证和自动修复\n        {\n            \"language\": \"html\",\n            \"autoFix\": true\n        },\n        {\n            \"language\": \"vue\",\n            \"autoFix\": true\n        }\n  ```","tags":["ESLint"],"categories":["VSCode"]},{"title":"MongoDB安装","url":"%2Fpages%2Fc5d54bc1%2F","content":"## MongoDB\n安装使用:\n1. 官网下载 MongoDB: https://www.mongodb.com/download-center#community\n2. 选择 Custom 安装\n3. 创建数据目录，**数据目录应该放在根目录下**(如: C:\\ )。\ndata\n├── db\n│   ├── mongo.config\n└── log\n    └── MongoDB.log\n4. 启动服务：`mongod --dbpath c:\\data\\db`， 由于windows power shell 限制，使用 `.\\mongod --dbpath c:\\data\\db`命令。\n5. 将 MongoDB 设为 windows 服务开机自启动：\n`mongod.exe --bind_ip yourIPadress --logpath \"C:\\data\\dbConf\\mongodb.log\" --logappend --dbpath \"C:\\data\\db\" --port yourPortNumber --serviceName \"YourServiceName\" --serviceDisplayName \"YourServiceName\" --install`\n    * --bind_ip\t绑定服务 IP，若绑定 127.0.0.1，则只能本机访问，不指定默认本地所有IP。\n    * --logpath\t指定 MongoDB 日志文件，注意是指定文件不是目录。\n    * --logappend\t使用追加的方式写日志。\n    * --dbpath\t指定数据库路径\n    * --port\t指定服务端口号，默认端口27017\n    * --serviceName\t指定服务名称\n    * --serviceDisplayName\t指定服务名称，有多个mongodb服务时执行。\n    * --install\t指定作为一个Windows服务安装。\n\n##  Robo 3T\n一个 Mongo 可视化工具，更便捷的操作 MongoDB 。\n1. 下载安装：https://robomongo.org/download\n1. windows 开启端口，控制面板 → 系统和安全 → Windows 防火墙 → 高级设置 → 入站规则 → 新建规则 → 端口 → 27017\n1. 打开 Robo 3T → create  → 设置 name 为 localhost → 端口为 27017  → save → connect","tags":["MongoDB"],"categories":["数据库"]},{"title":"html列表","url":"%2Fpages%2Fa465a2c5%2F","content":"\n## html 列表\n\n### 1. 无序列表\n使用标签: `ul` `li`\n**常用属性:**\n`disc`(实心圆)\n`circle`(空心圆)\n`square`(正方形)\n\n### 2. 有序列表\n使用标签: `ol` `li`\n**常用属性: **\n`A`(大写字母ABC编号)\n`a`(小写字母abc编号)\n`I`(大写罗马数字编号)\n`i`(小写罗马数字编号)\n`start`(规定编号从何值开始)\n\n### 3. 列表嵌套\n列表之间可以互相嵌套\n\n### 4. 自定义列表\n没有编号，只有列表格式。\n使用标签: `dl`(自定义列表) `dt`(列表项) `dd`(列表描述)","tags":["HTML"],"categories":["HTML"]},{"title":"Map和Set","url":"%2Fpages%2F5225cd1c%2F","content":"## Map 键值对\n> 一组键值对结构，查找速度快。储存具有映射关系的数据，例如身份证上面的姓名和身份证号码。\n\n### Map 函数\n```javascript\nvar map = new Map(); // 初始化 Map\nmap.set('XiaoMing', 22); // 添加键值对 key-value\nmap.set('HaHa', 66);\nmap.has('HaHa'); // 是否存在 'HaHa', 返回值为 true\nmap.get('XiaoMing'); // 22  获得对应的 value\nmap.delete('HaHa'); // 删除 key: 'HaHa'\n```\n一个 key 只能对应一个 value，对同一个 key，后添加的 value 会覆盖前面的 value。\n\n## Set\n> 一组 Key 值的集合，无序且不重复，不储存 Value。\n\n### Set 函数\n```javascript\nvar set = new Set(); // 初始化 Set\nset.add(6); // 添加 Key 6\nset.delete(6); // 删除 Key 6\n```","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Win10配置免安装MySQL","url":"%2Fpages%2Fe38ac448%2F","content":"\n1. #### 下载文件：\n\n   到 MySQL 官网https://dev.mysql.com/downloads/mysql/下载免安装版本: DOWNLOADS → MySQL Community Server → Windows (x86, 64-bit), ZIP Archive\n\n2. #### 创建配置文件：\n\n   将下载的 ZIP 文件解压至想要安装 MySQL 的文件夹，创建 mysql.ini 配置文件，保存退出。\n```ini\n[mysql]\n#设置mysql客户端默认字符集\ndefault-character-set = utf8\n[mysqld]\n#设置3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir = C:\\APPS\\MySQL\\mysql-5.7.18-winx64\n# 设置mysql数据库的数据的存放目录\ndatadir = C:\\APPS\\MySQL\\mysql-5.7.18-winx64\\data\n# 允许最大连接数\nmax_connections = 200\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server = utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine = INNODB\n```\n3. #### 设置环境变量：\n\n   右键桌面计算机→属性→高级系统设置→环境变量→系统变量Path→添加 MySQL 的bin目录路径，例如：C:\\APPS\\MySQL\\mysql-5.7.18-winx64\\bin 保存退出。\n\n4. #### 安装MySQL服务：\n\n   a. 以管理员模式打开命令行窗口，安装MySQL服务：\n\n   ```sql\n   mysqld -install\n   ```\n\n   b. 初始化data目录：\n\n   ```sql\n   mysqld –-initialize\n   ```\n\n   c. 启动MySQL服务：\n\n   ```sql\n   net start MySQL\n   ```\n\n   d. 用户登录：\n\n   ```sql\n   mysql -u root -p\n   ```\n\n   e. 输入密码：\n\n   初始随机密码存在于data目录下.err结尾的文件中，初始随机密码为root@localhost:后面的字符，例如：rCTmkIr:K65t\n\n   ```SQL\n   A temporary password is generated for root@localhost: rCTmkIr:K65t\n   ```\n\n   ​","tags":["MySql"],"categories":["数据库"]},{"title":"Gradle基础","url":"%2Fpages%2F691946d1%2F","content":"\n## Roay/app/build.gradle\n\n* 这个文件是app文件夹下这个Module的gradle配置文件，也可以算是整个项目最主要的gradle配置文件。\n\n  ​\n\n### 文件内容如下：\n\n```java\n// 声明是Android程序\napply plugin: 'com.android.application'\n\nandroid {\n    // 编译SDK的版本\n    compileSdkVersion 21\n    // build tools的版本\n    buildToolsVersion \"21.1.1\"\n\n    defaultConfig {\n    \t// 应用的包名\n        applicationId \"ly.roay\"\n        minSdkVersion 14\n        targetSdkVersion 21\n        versionCode 1\n        versionName \"1.0.0\"\n    }\n\n    // java版本\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_7\n        targetCompatibility JavaVersion.VERSION_1_7\n    }\n\n    buildTypes {\n        debug {\n            // debug模式\n        }\n\n        release {\n            // 是否进行混淆\n            minifyEnabled false\n            // 混淆文件的位置\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'\n        }\n    }\n\n    // 移除lint检查的error\n    lintOptions {\n      abortOnError false\n    }\n}\n\ndependencies {\n    // 编译libs目录下的所有jar包\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile 'com.android.support:support-v4:21.0.2'\n    compile 'com.etsy.android.grid:library:1.0.5'\n    compile 'com.alexvasilkov:foldable-layout:1.0.1'\n    // 编译extras目录下的ShimmerAndroid模块\n    compile project(':extras:ShimmerAndroid')\n}\n```\n\n## Roay/build.gradle\n\n* 这个文件是整个项目的gradle基础配置文。\n\n* 内容主要包含了两个方面：一个是声明仓库的源，这里可以看到是指明的jcenter(), 之前版本则是mavenCentral(), jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。另一个是声明了android gradle plugin的版本，android studio 1.0正式版必须要求支持gradle plugin 1.0的版本。\n\n  ### 文件内容如下：\n\n  ```java\n  // Top-level build file where you can add configuration options common to all sub-projects/modules.\n\n  buildscript {// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\n  buildscript {\n      repositories {\n          jcenter()\n      }\n      dependencies {\n          classpath 'com.android.tools.build:gradle:1.0.0'\n      }\n  }\n\n  allprojects {\n      repositories {\n          jcenter()\n      }\n  }\n      repositories {\n          jcenter()\n      }\n      dependencies {\n          classpath 'com.android.tools.build:gradle:2.2.0'\n\n          // NOTE: Do not place your application dependencies here; they belong\n          // in the individual module build.gradle files\n      }\n  }\n\n  allprojects {\n      repositories {\n          jcenter()\n      }\n  }\n\n  task clean(type: Delete) {\n      delete rootProject.buildDir\n  }\n  ```\n\n  ​\n\n  ​","tags":["Gradle"],"categories":["Android"]},{"title":"Android简易计分板实现","url":"%2Fpages%2F81bae912%2F","content":"\n### 一、View的选择 ###\n- 分析整个 APP 的组成：\n    - TextView：  4 个\n    - Button： 7个\n    - 空白 View：1个\n\n### 二、Layout布局 ###\n\n- 采用 RelativeLayout 作为整体布局父容器。\n- 将其分为上下两个部分，下面部分只有一个 Button ，直接设置好其相对于父视图的位置参数以及自身属性即可。\n- 上面部分又可以横向分为三个部分：\n    - 1.TeamA 团队的加分 Button 及显示的 TextView；\n        - 对于 TeamA， 其中各组件纵向排列，可采用Vertical LinearLayout作为其视图容器。\n    - 2.空白 View 做中间隔离；\n    - 3.TeamB 团队的加分 Button 及显示的 TextView 。\n        - 对于 TeamB，其设置等同于 TeamA 的设置。\n- 可以采用 Horizontal LinearLayout 作为其视图容器。\n\n#### 整体布局 active_main.xml 代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/activity_main\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:background=\"#D2403E\"\n    android:padding=\"@dimen/activity_vertical_margin\"\n    tools:context=\"com.roojay.android.courtcounter.MainActivity\">\n\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"18dp\"\n        android:orientation=\"horizontal\">\n\n        <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:orientation=\"vertical\">\n\n            <TextView\n                style=\"@style/textView\"\n                android:id=\"@+id/teama_text_view\"\n                android:text=\"@string/team_a\" />\n\n            <TextView\n                android:id=\"@+id/pointsa_text_view\"\n                style=\"@style/pointsTextView\"\n                android:text=\"@string/points_a\" />\n\n            <Button\n                style=\"@style/addButtonView\"\n                android:id=\"@+id/buttona3\"\n                android:onClick=\"addThreeA\"\n                android:text=\"@string/add3a\" />\n\n            <Button\n                style=\"@style/addButtonView\"\n                android:id=\"@+id/buttona2\"\n                android:onClick=\"addTwoA\"\n                android:text=\"@string/add2a\" />\n\n            <Button\n                style=\"@style/addButtonView\"\n                android:id=\"@+id/buttona1\"\n                android:onClick=\"addOneA\"\n                android:text=\"@string/add1a\" />\n        </LinearLayout>\n\n        <View\n            android:layout_width=\"1dp\"\n            android:layout_height=\"match_parent\"\n            android:layout_marginTop=\"8dp\"\n            android:layout_marginBottom=\"8dp\"\n            android:background=\"#FFFEFE\" />\n\n\n        <LinearLayout\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\"\n            android:layout_weight=\"1\"\n            android:orientation=\"vertical\">\n\n            <TextView\n                style=\"@style/textView\"\n                android:id=\"@+id/teamb_text_view\"\n                android:text=\"@string/team_b\" />\n\n            <TextView\n                style=\"@style/pointsTextView\"\n                android:id=\"@+id/pointsb_text_view\"\n                android:text=\"@string/points_b\" />\n\n            <Button\n                style=\"@style/addButtonView\"\n                android:id=\"@+id/buttonb3\"\n                android:onClick=\"addThreeB\"\n                android:text=\"@string/add3b\" />\n\n            <Button\n                style=\"@style/addButtonView\"\n                android:id=\"@+id/buttonb2\"\n                android:onClick=\"addTwoB\"\n                android:text=\"@string/add2b\" />\n\n            <Button\n                style=\"@style/addButtonView\"\n                android:id=\"@+id/buttonb1\"\n                android:onClick=\"addOneB\"\n                android:text=\"@string/add1b\" />\n\n        </LinearLayout>\n    </LinearLayout>\n\n    <Button\n        style=\"@style/resetButtonView\"\n        android:id=\"@+id/button_reset\"\n        android:onClick=\"reset\"\n        android:text=\"@string/reset_text_views\" />\n\n\n</RelativeLayout>\n\n```\n\n### 三、交互 ###\n\n- 通过 Button 的 android:onClick 属性指定方法。\n- 将各个 Button 与 Java 中的方法关联起来。\n- 具体操作是在 active_main.xml 中设置 android:onClick=\"buttonName\" 为每个 Button 设置一个独特的名字，这个名字用于 Java 代码寻找和识别每个不同的 Button 。\n\n例如：\n\n```xml\n在 active_main.xml 中设置 Button3A 的 onClick 属性为 android:onClick=\"addThreeA\"\n```\n在 MainActivity.java 中编写代码：\n\n```java\n    public void addThreeA(View view) {\n\n    //所需要执行的操作，假如是 A 团队加三分\n\n    }\n```\n\n那么当你按下 Button3A 就将 A 团队的分数加上三分。\n\n#### 整个 MainActivity.java 代码  ####\n\n```java\npackage com.roojay.android.courtcounter;\n\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.View;\nimport android.widget.TextView;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    int scorea = 0;\n    int scoreb = 0;\n\n\n    /**\n     * Add 3 points for the Team A.\n     */\n    public void addThreeA(View view) {\n        scorea = scorea + 3;\n        displayTeamscorea(scorea);\n    }\n\n    /**\n     * Add 2 points for the Team A.\n     */\n    public void addTwoA(View view) {\n        scorea = scorea + 2;\n        displayTeamscorea(scorea);\n    }\n\n    /**\n     * Add 1 point for the Team A.\n     */\n    public void addOneA(View view) {\n        scorea = scorea + 1;\n        displayTeamscorea(scorea);\n    }\n\n    /**\n     * Displays the given scorea for Team A.\n     */\n    public void displayTeamscorea(int scorea) {\n        TextView scoreaView = (TextView) findViewById(R.id.pointsa_text_view);\n        scoreaView.setText(String.valueOf(scorea));\n    }\n\n\n    /**\n     * Add 3 points for the Team B.\n     */\n    public void addThreeB(View view) {\n        scoreb = scoreb + 3;\n        displayTeamscoreb(scoreb);\n    }\n\n    /**\n     * Add 2 points for the Team B.\n     */\n    public void addTwoB(View view) {\n        scoreb = scoreb + 2;\n        displayTeamscoreb(scoreb);\n    }\n\n    /**\n     * Add 1 point for the Team B.\n     */\n    public void addOneB(View view) {\n        scoreb = scoreb + 1;\n        displayTeamscoreb(scoreb);\n    }\n\n    /**\n     * Displays the given scoreb for Team B.\n     */\n    public void displayTeamscoreb(int scoreb) {\n        TextView scorebView = (TextView) findViewById(R.id.pointsb_text_view);\n        scorebView.setText(String.valueOf(scoreb));\n    }\n\n\n    public void reset(View view) {\n        scorea = 0;\n        scoreb = 0;\n        displayTeamscorea(scorea);\n        displayTeamscoreb(scoreb);\n\n    }\n}\n\n```\n### 四、代码优化及 APP 美化 ###\n#### style.xml 的设置\n\n- 当每一个 View 都有着大量相同的元素，可以将这些元素定义在\n`res/value/styles.xml` 中。\n\n具体的写法如下：\n\n```xml\n<style name=\"cofe_textView\">\n        <item name=\"android:textColor\">#FFFFFF</item>\n        <item name=\"android:layout_width\">wrap_content</item>\n       ...\n\n    </style>\n```\n\n然后可以用`style=\"@style/cofe_textView\"`语句轻易地重复引用这些设置：\n\n例如：\n```xml\n<TextView\n              style=\"@style/textView\"\n              android:id=\"@+id/teamb_text_view\"\n              android:text=\"@string/team_b\" />\n\n```\n\n#### 整个 style.xml 代码如下 ####\n```xml\n<resources>\n\n    <!-- Base application theme. -->\n    <style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\">\n        <!-- Customize your theme here. -->\n        <item name=\"colorPrimary\">@color/colorPrimary</item>\n        <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\n        <item name=\"colorAccent\">@color/colorAccent</item>\n    </style>\n\n    <style name=\"textView\">\n        <item name=\"android:layout_width\">match_parent</item>\n        <item name=\"android:layout_height\">wrap_content</item>\n        <item name=\"android:fontFamily\">sans-serif-medium</item>\n        <item name=\"android:gravity\">center</item>\n        <item name=\"android:textColor\">#FFFEFE</item>\n        <item name=\"android:textSize\">24sp</item>\n    </style>\n\n    <style name=\"pointsTextView\">\n        <item name=\"android:layout_width\">match_parent</item>\n        <item name=\"android:layout_height\">wrap_content</item>\n        <item name=\"android:fontFamily\">sans-serif-medium</item>\n        <item name=\"android:layout_margin\">24dp</item>\n        <item name=\"android:gravity\">center</item>\n        <item name=\"android:textColor\">#2B2A2A</item>\n        <item name=\"android:textSize\">56sp</item>\n        <item name=\"android:background\">#FFFEFE</item>\n    </style>\n\n    <style name=\"addButtonView\">\n        <item name=\"android:layout_width\">match_parent</item>\n        <item name=\"android:layout_height\">wrap_content</item>\n        <item name=\"android:layout_marginBottom\">8dp</item>\n        <item name=\"android:layout_marginLeft\">24dp</item>\n        <item name=\"android:layout_marginRight\">24dp</item>\n        <item name=\"android:background\">#2B2A2A</item>\n        <item name=\"android:textColor\">#FFFEFE</item>\n    </style>\n\n    <style name=\"resetButtonView\">\n        <item name=\"android:layout_width\">wrap_content</item>\n        <item name=\"android:layout_height\">wrap_content</item>\n        <item name=\"android:layout_marginBottom\">32dp</item>\n        <item name=\"android:background\">#2B2A2A</item>\n        <item name=\"android:textColor\">#FFFEFE</item>\n        <item name=\"android:layout_centerHorizontal\">true</item>\n        <item name=\"android:layout_alignParentBottom\">true</item>\n    </style>\n\n</resources>\n\n```\n#### strings.xml ####\n- 在 Android 中会将应用中出现的文字放入 string.xml 中，这样一个字符可以重复调用，而不用每次去编写，可以减少数据的冗余，减小 APP 应用的体积。并且当你的 APP 国际化时只需更改 strings.xml 中的文字定义，就可以实现其他语言的显示。\n\nstrings.xml 中的字符定义如下：\n```xml\n<resources>\n    <string name=\"text_name\">显示的文字</string>\n    ...\n</resources>\n\n```\n调用时：\n```xml\nandroid:text=\"@string/text_name\"\n```\n#### 整个 strings.xml 代码如下 ####\n```xml\n<resources>\n    <string name=\"app_name\">Court Counter</string>\n    <string name=\"add2b\">+2 points</string>\n    <string name=\"add1b\">+1 pointsb</string>\n    <string name=\"team_a\">Team A</string>\n    <string name=\"add2a\">+2 points</string>\n    <string name=\"points_a\">0</string>\n    <string name=\"add3a\">+3 points</string>\n    <string name=\"add1a\">+1 points</string>\n    <string name=\"team_b\">Team B</string>\n    <string name=\"points_b\">0</string>\n    <string name=\"add3b\">+3 points</string>\n    <string name=\"reset_text_views\">reset</string>\n</resources>\n\n```\n### 五、APP 强制锁定横竖屏 ###\n\n- 在最开始做出 APP 时没有考虑到 APP 横屏的问题，偶然一次横屏之后发现 APP 显示不全了，当时也没多想，既然横屏不行，那就去掉横屏显示，锁定在竖屏。上网查了下资料，锁定横竖屏有两种实现方式：XML 或 Java 方式。这个 APP 采用了 XML 锁定方式。\n\n#### XML锁定横屏或竖屏\n\n- 在AndroidManifest.xml中配置,在Activity标签中加入android:screenOrientation=\"unspecified\"，来使某个Activity做横竖屏的变化。\n\n- 使用android:screenOrientation=\"unspecified\"来锁定横竖屏。\n\n  - unspecified：未指明屏幕方向。\n  - landscape：锁定为横屏。\n  - portrait：锁定为竖屏。\n\n  ##### 具体代码如下：\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n      package=\"com.roojay.android.courtcounter\">\n\n      <application\n          android:allowBackup=\"true\"\n          android:icon=\"@mipmap/ic_launcher\"\n          android:label=\"@string/app_name\"\n          android:supportsRtl=\"true\"\n          android:theme=\"@style/AppTheme\" >\n          <activity android:name=\".MainActivity\"\n              android:screenOrientation=\"portrait\">\n              <intent-filter>\n                  <action android:name=\"android.intent.action.MAIN\" />\n\n                  <category android:name=\"android.intent.category.LAUNCHER\" />\n              </intent-filter>\n          </activity>\n      </application>\n\n  </manifest>\n  ```\n\n  #### Java代码锁定横竖屏\n\n  - 在onCreate()方法中加入锁定代码。\n\n  ##### 代码如下：\n\n  ```java\n  public class MainActivity extends AppCompatActivity {\n\n      @Override\n      protected void onCreate(Bundle savedInstanceState) {\n          super.onCreate(savedInstanceState);\n          setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);//锁定为横屏\n        //setRequestedOrientation(ActivityInfo .SCREEN_ORIENTATION_PORTRAIT);//锁定为竖屏\n          setContentView(R.layout.activity_main);\n      }\n  ```\n\n### 六、APP 演示及源码 ###\n\n- APP 的最终效果图，没有进行多余的其他手机测试，也不知道其他手机显示效果是不是这样。\n\n![]()\n\n演示视频：\n[http://omjmn55ir.bkt.clouddn.com/%E7%AF%AE%E7%90%83%E8%AE%A1%E5%88%86%E6%9D%BF%E6%BC%94%E7%A4%BAmp4](http://omjmn55ir.bkt.clouddn.com/%E7%AF%AE%E7%90%83%E8%AE%A1%E5%88%86%E6%9D%BF%E6%BC%94%E7%A4%BAmp4 \"演示视频\")\n\n源码：\n[https://github.com/roojay520/CourtCounter](https://github.com/roojay520/CourtCounter \"源码\")\n","tags":["Android"],"categories":["Android"]},{"title":"Java基础与Button交互","url":"%2Fpages%2Fb8bb4b60%2F","content":"## 变量的定义\n> 在程序的运行过程中，会产生一些临时数据储存在内存单元中，这每一个内存单元都用一个标识符来标识，这些内存单元被称为变量。\n### 变量的数据类型\n> 变量的数据类型分为两种，即基本数据类型和引用数据类型。\n#### 1. 基本数据类型 ####\n1. 数值型分为两种：\n    1.1  整数类型（byte 1字节，short 2字节，int 4字节，long 8字节）\n    1.2 浮点类型（float 4字节，double 8字节）\n2. 字符型（char）2字节\n3. 布尔型（boolean）1字节\n#### 2. 引用数据类型 ####\n1. 类（class)\n2. 接口（interface）\n3. 数组\n4. 枚举（enum）\n5. 注解（annotation）\n### 变量类型转换 ###\n> 在程序中，当把一种数据类型的值赋值给另一种数据类型时，需要进行数据类型的转换。数据类型转换分为两种：自动类型转换和强制类型转换。\n#### 1. 自动类型转换 ####\n> 两种数据类型转换不需要显式声明，自动转换类型必须满足两个条件：两种数据类型彼此兼容和转换目标类型的取值范围必须大于原来类型的取值范围。\n1. byte→short，int，long\n2. short，char→int，long\n3. int→long\n4. byte，char，short，int→float\n5. byte，char，short，int，long，float→double\n6. boolean类型无法转换为其他类型。\n#### 2. 强制类型转换 ####\n> 自动转换类型无法进行转换时，进行强制类型转换。取值范围较大的数据类型转换为取值范围较小的类型，可能会造成精度丢失。\n\n例如：\n```java\nint num;\nbyte b =(byte)num;\n```\n## 常量\n\n> 在编程语言中，**常量**是指在整个程序中永远不会改变的值。在 Java 中，你可以使用关键字 `final` 来强制规定某个值不得被更改。例如：\n```java\nfinal int POINTS_FOR_FREE_THROW = 1;\n```\nThen if you wrote the following, you'd get an error:\n```java\nPOINTS_FOR_FREE_THROW = 100;\n```\n- 注意，按照惯例，常量的名称全为大写形式。此外，单词之间用下划线连接，而不用空格或用骆驼拼写法。你可以将变量声明为常量，防止自己意外地更改了变量的值。\n## 方法 ##\n> 为解决代码重复编写的问题所设计的特定功能代码块。\n> 方法不能嵌套。\n> main（）方法的作用：调用方法的实例化对象。\n\n方法结构一般为：\n```java\n修饰符 返回值类型 方法名（参数类型 参数1，参数类型 参数2，...）{\n    执行语句\n    ...\n    ...\n    return 返回值；\n}\n```\n## 选择结构语句\n### if条件语句\n> 当判断条件1结果为 true 时，执行语句 1，为 false 时，执行语句 2。当判断条件 1, 2 都不满足 true 时，执行语句 3。\n\n例如：\n```java\nif (判断条件1){\n  执行语句1\n}\nelse if(判断条件2){\n  执行语句2\n}\nelse{\n  执行语句3\n}\n```\n### 三元运算 ###\n> 一种类似于 if-else 语句的运算，三元运算一般会得到一个结果，一般用来对某个变量进行赋值。\n> 当判断条件成立时结果为表达式1的值，否则表达式2的值。\n```java\n判断条件 ? 表达式 1 : 表达式 2\n```\n例如：求取两个数 x，y 中较大的值。\n```java\n//if-else 实现方法\nint x, y, max;\nif(x>y){\n    max = x;\n}\nelse{\n    max = y;\n}\n\n//三元运算实现\nint x, y, max;\nmax = x > y ? x : y;\n\n```\n### switch语句\n> 在 switch 语句中使用 switch 关键字来描述一个表达式，使用case关键字来描述和表达式结果比较的目标值，\n> 当表达式的值和某个目标值匹配时，会执行对应 case 下的语句。\n\n例如：\n```java\nswitch(表达式){\n  case 1:\n    执行语句1;\n       break; //break终止case并跳出switch循环\n  case 2:\n    执行语句2;\n     break;\n  case 3:\n    执行语句3；\n      break;\n  default: //default处理和前面的case都不匹配的值\n    执行语句4;\n      break;\n}\n```\n## 循环结构语句\n### while 循环语句\n> 循环条件判断为 true 时，执行语句循环执行，直到循环条件为 false。\n\n例如：\n```java\nwhile(循环条件){\n    执行语句\n}\n```\n### do...while循环语句\n> 循环体会无条件执行一次，然后根据循环条件决定是否继续执行。\n\n例如：\n```java\ndo{\n  执行语句\n}\nwhile(循环条件);\n```\n### for循环语句\n\n> 一般用在循环次数已知的情况下，循环条件 ② 判断为 true 时，执行顺序为： ①→②→④→③，初始化表达式 ① 只在第一次循环时执行。\n\n例如：\n```java\nfor(初始化表达式①;循环条件②;操作表达式③){\n  执行语句④\n}\n```\n```java\n/**\n* Created by Roojay on 2017/4/7.\n* 利用嵌套循环打印一个正三角形。\n*/\npublic class Test1 {\n    public static void main(String args[]){\n        int i, j, k;\n        for(i = 1; i <= 5; i++){\n            for(k = 0; k < 5 - i; k++){\n                System.out.print(\" \");\n            }\n            for(j = 1; j <= i; j++){\n                System.out.print(\"* \");\n            }\n\n            System.out.println();\n        }\n\n    }\n}\n```\n### 跳转语句\n#### break语句\n> 当它出现在 switch 条件语句中时，作用是终止某个 case 并跳出 switch 结构。\n> 当它出现在循环语句中，作用是跳出循环语句，执行后面的代码。\n> 当它出现在嵌套循环内层循环中时，只能跳出内层循环，如果想跳出外层循环，\n> 需要对外层前面添加标记 itcast： ，在后面使用 break itcast 跳出外层循环。\n#### continue语句\n> continue 语句用在循环语句中，它的作用是终止本次循环，执行下一次循环。\n> 也可以使用标记结束外循环。\n## Button交互\n- XML 布局文件中的 <Button> 元素创建 Button，则可以使用该元素的 android:onClick 属性指定方法。这一方便的备选方案专为不改变行为的 Button 提供。\n- android:onClick=\"buttonName\"\n### 屏幕输出显示\n#### MainActivity.java部分\n```java\n    public void display(String text) {\n        TextView t = (TextView) findViewById(R.id.display_text_view);\n        t.setText(text);\n    }\n\n    public void display(int text) {\n        TextView t = (TextView) findViewById(R.id.display_text_view);\n        t.setText(text + \"\");\n    }\n```\n- 其中 R.id.display_text_view中的display_text_view是指具体输出显示的TextView的ID。\n\n#### activity_main.xml部分\n\n```xml\n    <TextView\n        android:id=\"@+id/display_text_view\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"\"\n        android:textSize=\"45sp\"\n        android:textColor=\"#000000\"/>\n```\n### Style\n- 下面两个 TextView 都设置着大量相同的元素：\n```xml\n<TextView\n        android:id=\"@+id/tell\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_above=\"@id/adress\"\n        android:text=\"电话:028-666666\"\n        android:textSize=\"24sp\"\n        android:textColor=\"#FFFFFF\"\n        android:background=\"#795548\"\n        android:layout_marginLeft=\"8dp\"\n        android:layout_marginTop=\"8dp\" />\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_above=\"@id/tell\"\n        android:text=\"半岛咖啡\"\n        android:textSize=\"30sp\"\n        android:textColor=\"#FFFFFF\"\n        android:background=\"#795548\"\n        android:layout_marginLeft=\"8dp\" />\n<!-- 相同的元素 -->\n<TextView\n    android:textColor=\"#FFFFFF\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"#795548\"\n    android:layout_marginLeft=\"8dp\" />\n```\n- 可以在`res/value/styles.xml`里定义个 style 来包括这些通用的元素设置：\n\n```xml\n<style name=\"cofe_textView\">\n        <item name=\"android:textColor\">#FFFFFF</item>\n        <item name=\"android:layout_width\">wrap_content</item>\n        <item name=\"android:layout_height\">wrap_content</item>\n        <item name=\"android:background\">#795548</item>\n        <item name=\"android:layout_marginLeft\">8dp</item>\n    </style>\n```\n\n然后可以用以下一句语句轻易地重复引用这些设置：\n```xml\nstyle=\"@style/cofe_textView\"\n```\n\n这一段 TextView 可以重构为以下：\n\n```xml\n\n<TextView\n        style=\"@style/cofe_textView\"\n        android:id=\"@+id/tell\"\n        android:layout_above=\"@id/adress\"\n        android:text=\"电话:028-666666\"\n        android:textSize=\"24sp\"\n        android:layout_marginTop=\"8dp\" />\n<TextView\n        style=\"@style/cofe_textView\"\n        android:layout_above=\"@id/tell\"\n        android:text=\"半岛咖啡\"\n        android:textSize=\"30sp\" />\n```","tags":["Android"],"categories":["Java"]},{"title":"Android View&Layout","url":"%2Fpages%2F29c8a334%2F","content":"## View 视图\n\n### TextView\n\n-   字体大小属性：**android:textSize=\"36sp\"**\n\n- 或者采用另一种字体大小定义方式：\n\n    **android:textAppearance=\"?android:textAppearanceLarge\"**\n\n    As of API 19 (KitKat):\n\n    - *?android:textAppearanceSmall* is currently 14sp\n    - *?android:textAppearanceMedium* is currently 18sp\n    - *?android:textAppearanceLarge* is currently 22sp\n\n- 文字颜色属性：**android:textColor**\n\n- 文本变成大写：**android:textAllCaps=\"true\"**\n\n- 字体属性：**android:textStyle=\"bold\"**  bold:粗体；italic:斜体；bolditalic:粗斜体。\n\n- 属性：**android:fontFamily=\"sans-serif-light\"** 字体设置。\n\n- 属性值 wrap_conent:自适应大小。\n\n- **gravity**中文意思是”重心“，就是表示view横向和纵向的停靠位置\n\n    - **android:gravity：**是对view控件本身来说的，是用来设置view本身的内容应该显示在view的什么位置，默认值是左侧。也可以用来设置布局中的控件位置\n    - **android:layout_gravity：**是相对于包含该元素的父元素来说的，设置该元素在父元素的什么位置；\n    - 比如TextView: android:layout_gravity表示TextView在界面上的位置，android:gravity表示TextView文本在TextView的什么位置，默认值是左侧.\n\n    ​\n    ```xml\n    <TextView\n              android:text=\"Hello Android!\"\n              android:background=\"@android:color/darker_gray\"\n              android:layout_width=\"150dp\"\n              android:layout_height=\"75dp\" />\n\n    <!-- 注释内容 -->\n    ```\n\n### ImageView\n\n- 属性: android:scaleType=\"center\":不改变图片大小居中显示。\n- 属性: android:scaleType=\"centerCrop\":自适应屏幕居中显示。\n\n\n  ```xml\n\n  <ImageView\n               android:src=\"@drawable/cake\"\n               android:layout_width=\"wrap_content\"\n               android:layout_height=\"wrap_content\"\n               android:scaleType=\"center\"  />\n  ```\n\n### Button\n\n- XML 布局文件中的 <Button> 元素创建 Button，则可以使用该元素的 android:onClick 属性指定方法。这一方便的备选方案专为不改变行为的 Button 提供。\n- android:onClick=\"buttonname\"\n\n\n## Layout 布局\n### LinearLayout线性布局\n\n-   View水平or垂直方向排列。\n  - 属性：android:orientation=\"vertical\" 决定布局以垂直(列)显示。\n  - 属性：android:orientation=\"horizontal\"决定布局以水平(行)显示。\n\n    ```xml\n    <LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n    <TextView\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"1\"/>\n    <TextView\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"2\"/>\n    <TextView\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"3\"/>\n    </LinearLayout>\n    ```\n\n     ![](http://i.imgur.com/dkCwMv0.png)\n\n### Layout Weight\n\n- layout_weight:视图权重。\n  - vertical(垂直)时设置layout_height为0，设置layout_weight为1.\n  - horizontal(水平)时设置layout_width为0，设置layout_weight为1.\n\n### RelativeLayout相对布局\n\n#### 相对于父视图边缘位置对齐\n\n-   上边缘对齐：android:layout_alignParentTop=\"true\"\n  - 下边缘对齐：android:layout_alignParentBottom=\"true\"\n  - 左边缘对齐：android:layout_alignParentLeft=\"true\"\n  - 右边缘对齐：android:layout_alignParentRight=\"true\"\n  - 垂直方向居中：android:layout_centerVertical=\"true\"\n  - 水平方向居中：android:layout_centerHorizontal=\"true\"\n  - 屏幕居中：android:layout_centerInParent=\"true\"\n\n    ```xml\n    <RelativeLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_alignParentTop=\"true\"\n    android:layout_alignParentLeft=\"true\"\n    android:text=\"1\"/>\n    <TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_alignParentTop=\"true\"\n    android:layout_centerHorizontal=\"true\"\n    android:text=\"2\"/>\n      <TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_alignParentTop=\"true\"\n    android:layout_alignParentRight=\"true\"\n    android:text=\"3\"/>\n    <TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_centerVertical=\"true\"\n    android:layout_alignParentLeft=\"true\"\n    android:text=\"4\"/>\n    <TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_centerInParent=\"true\"\n    android:text=\"Center\"/>\n      <TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_centerVertical=\"true\"\n    android:layout_alignParentRight=\"true\"\n    android:text=\"5\"/>\n    <TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_alignParentBottom=\"true\"\n    android:layout_alignParentLeft=\"true\"\n    android:text=\"6\"/>\n    <TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_alignParentBottom=\"true\"\n    android:layout_centerHorizontal=\"true\"\n    android:text=\"7\"/>\n    <TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:layout_alignParentBottom=\"true\"\n    android:layout_alignParentRight=\"true\"\n    android:text=\"8\"/>\n    </RelativeLayout>\n    ```\n\n    ​\n\n    ![](http://i.imgur.com/2e9IPMB.png)\n\n\n\n\n\n\n#### 相对于其它视图定位\n\n- android:id=\"@+id/viewname_text_view\"\n- 符号“@”表示Android应用中的资源。\n- 位于center上边：android:layout_above=\"@id/center\"\n- 位于center下边：android:layout_below=\"@id/center\"\n- 位于center左边：android:layout_toLeftOf=\"@id/center\"\n- 位于center右边：android:layout_toRightOf=\"@id/center\"\n\n ```xml\n <RelativeLayout\n android:layout_width=\"match_parent\"\n android:layout_height=\"match_parent\">\n <TextView\n android:id=\"@+id/center\"\n android:layout_width=\"wrap_content\"\n android:layout_height=\"wrap_content\"\n android:layout_centerInParent=\"true\"\n android:text=\"Center\"/>\n <TextView\n android:layout_width=\"wrap_content\"\n android:layout_height=\"wrap_content\"\n android:layout_toLeftOf=\"@id/center\"\n android:layout_alignBottom=\"@id/center\"\n android:text=\"2\"/>\n <TextView\n android:layout_width=\"wrap_content\"\n android:layout_height=\"wrap_content\"\n android:layout_toRightOf=\"@id/center\"\n android:layout_alignBottom=\"@id/center\"\n android:text=\"3\"/>\n <TextView\n android:layout_width=\"wrap_content\"\n android:layout_height=\"wrap_content\"\n android:layout_above=\"@id/center\"\n android:layout_alignLeft=\"@id/center\"\n android:text=\"1\"/>\n <TextView\n android:layout_width=\"wrap_content\"\n android:layout_height=\"wrap_content\"\n android:layout_below=\"@id/center\"\n android:layout_alignLeft=\"@id/center\"\n android:text=\"4\"/>\n </RelativeLayout>\n ```\n\n ![](http://i.imgur.com/wyQuZei.png)\n\n### 内边剧和外边距\n\n#### 内边距(padding)\n\n- android:padding=\"8dp\"\n\n  OR\n\n  - android:paddingLeft=\"8dp\"\n  - android:paddingRight=\"8dp\"\n  - android:paddingTop=\"8dp\"\n  - android:paddingBottom=\"8dp\"\n  - 默认值为0\n\n#### 外边距(magin)\n\n- android:layout_margin=\"8dp\"\n\n  OR\n\n  - android:layout_marginLeft=\"8dp\"\n\n  - android:layout_marginRight=\"8dp\"\n\n  - android:layout_marginTop=\"8dp\"\n\n  - android:layout_marginBottom=\"8dp\"\n  - 默认值为0\n\n![](http://i.imgur.com/sjGdzlh.png)\n\n### 创建视图\n\n1. 选择Views ；\n2. 摆放Views；\n3. 设计Views样式。","tags":["Android"],"categories":["Android"]},{"title":"Java中的异常","url":"%2Fpages%2Ff029d2bb%2F","content":"\n1. 什么是异常\n2. 异常的分类\n3. try...catch...finally结构的使用方法\n\n## 1. 什么是异常？  ##\n\n>\n* 异常(Exception)：中断了正常指令流的事件。\n* 异常是一个对象；\n* 异常产生于程序运行时；\n* 指令流：程序执行时一系列的连续指令称为指令流。\n>\n示例：\n```java\nclass Test{\n\tpublic static void main(String args[]){\n\t\tint i = 1 / 0;\n\t}\n}\n```\n 抛出异常：\n>Exception in thread \"main\" java.lang.ArithmeticException: / by zero\n\tat Test3.main(Test3.java:6)\n\n* Exception in thread \"main\" ：在主线程中出现异常；\n* ArithmeticException：异常的名称，算术异常；\n* / by zero：被0除；\n* at Test.main(Test.java:3)：异常位置；\n\n## 2. 异常的分类 ##\n### JDK提供的类： ###\n\n> ![](http://i.imgur.com/gTBhe2x.png)\n1.  Throwable：所有异常的父类；\n2.  Error：虚拟机运行时产生的错误，产生错误，虚拟机直接关闭；\n3.   Exception： 分为UncheckExeption（RuntimeExeption）和CheckExeption\n>\nRuntimeException + Error 和其子类都是属于uncheckexception\nException类中除了 RuntimeException之外的类，都是属于checkexception\n\n#### Exception ####\n##### checkException #####\n>\ncheckException是必须要处理的，也就是不能抛出，必须通过try-catch来完成，不处理的话是不能进行编译的。\n示例：\n```java\nclass TestCheck{\n\tpublic static void main(String args[]){\n        //CheckException\n\t\tThread.sleep(1000); //让当前线程休眠1000ms\n\t}\n}\n```\n运行结果：\n![](http://i.imgur.com/xMd1LOi.png)\n\n##### uncheckException（ RuntimeException） #####\n>\n运行时异常包括平常遇到的各种异常，如空指针异常，数据格式异常等一系列异常，这种异常是可以不捕获的，可通过throws抛出异常，交给别的代码或者JAVA虚拟机来完成\n示例：\n```java\nclass Test{\n\tpublic static void main(String args[]){\n\t\t//UncheckException\n\t\tint i = 1 / 0;\n\t}\n}\n```\n运行结果：\n![](http://i.imgur.com/ll7JnfN.png)\n\n## 3. try...catch...finally结构 ##\n>\n```java\ntry{\n       //代码A\n\t//有可能出现异常的代码B\n\t//代码C\n}\ncatch(Exception e){ //虚拟机产生的异常对象e\n\te.printStackTrace(); //处理异常的代码D\n\t//代码E\n}\nfinally{\n\t//异常的出口\n\t//执行扫尾工作的代码F\n}\n```\n#### 如果try中代码B没有异常：执行代码A-B-C-F\n#### 如果try中代码B出现异常：执行代码A-B-D-E-F\n\n### uncheckException ###\n>\n```java\n//uncheckException\nclass TestCheck{\n\tpublic static void main(String args[]){\n\t\tSystem.out.println(1);\n\t\ttry{\n\t\t\tSystem.out.println(2);\n\t\t\t//有可能出现异常的代码\n\t\t\tint i = 1/0;\n\t\t\tSystem.out.println(3);\n\t\t}\n\t\tcatch(Exception e){ //虚拟机产生的异常对象e\n\t\t\te.printStackTrace(); //打印异常栈的追踪信息\n\t\t\tSystem.out.println(4);\n\t\t}\n\t\tfinally{\n\t\t\t//异常的出口\n\t\t\tSystem.out.println(\"finally\");\n\t\t}\n\t}\n}\n```\n运行结果：\n![](http://i.imgur.com/DG4HLEn.png)\n\n### checkException ###\n>\n```java\n//checkException\nclass TestCheck{\n\tpublic static void main(String args[]){\n\t\tSystem.out.println(1);\n\t\ttry{\n\t\t\tSystem.out.println(2);\n\t\t\t//有可能出现异常的代码\n\t\t\tThread.sleep(1000); //让当前线程休眠1000ms\n\t\t\tSystem.out.println(3);\n\t\t}\n\t\tcatch(Exception e){ //虚拟机产生的异常对象e\n\t\t\te.printStackTrace(); //打印异常栈的追踪信息\n\t\t\tSystem.out.println(4);\n\t\t}\n\t\tfinally{\n\t\t\t//异常的出口\n\t\t\tSystem.out.println(\"finally\");\n\t\t}\n\t}\n}\n```\n运行结果：\n![](http://i.imgur.com/yWIuLO9.png)\n屏幕首先显示1，2，然后停顿1000ms，再显示3和finally\n\n","tags":["Java"],"categories":["Java"]},{"title":"throw和throws","url":"%2Fpages%2F29cc0096%2F","content":"\n## throw ##\n### throw的作用 ###\n\n- 如果Java虚拟机不能判断异常e，可以生成异常对象e，用throw加上这个异常对象抛出这个异常。\n>\n示例：\n```java\npackage src;\nclass People{\n\tprivate int age;\n\tpublic void setAge(int age){\n\t\tif(age < 0){\n\t\t\tRuntimeException e = new RuntimeException(\"年龄不能为负数\");\n\t\t\tthrow e;\n\t\t}\n\t\tthis.age = age;\n\t\tSystem.out.println(age);\n\t}\n}\nclass Test{\n\tpublic static void main(String args[]){\n\t\tPeople people = new People();\n\t\tpeople.setAge(-20);\n\t}\n}\n```\n\n运行结果：\n![](http://i.imgur.com/hSqdO9z.png)\n\n\n##  throws ##\n### throws ###\n\n- 声明一个函数可能产生异常，函数不对异常进行处理，在调用函数的地方对异常进行处理。\n>\n示例：\n```java\npackage src1;\nclass People{\n\tprivate int age;\n\tpublic void setAge(int age)  throws Exception{\n\t\tif(age < 0){\n\t\t\tException e = new Exception(\"年龄不能为负数\");\n\t\t\tthrow e;\n\t\t}\n\t\tthis.age = age;\n\t\tSystem.out.println(age);\n\t}\n}\nclass Test{\n\tpublic static void main(String args[]){\n\t\tPeople people = new People();\n\t\ttry{\n\t\t\tpeople.setAge(-20);\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n}\n```\n运行结果：\n![](http://i.imgur.com/wJqKdCu.png)","tags":["Java"],"categories":["Java"]},{"title":"接口应用","url":"%2Fpages%2F75336bdc%2F","content":"\n> 接口定义一种标准：\n\n1. 通过interface定义；\n2. 函数都是抽象函数（只有函数没有函数体）；\n3. 子类通过implements实现；对接口里面的抽象函数进行override；\n```java\n/**\n*定义一个Printer接口，通过HPPrinter，CanonPrinter两个子类去实现\n*/\npackage printer;\n //定义一个Printer接口\ninterface Printer{\n    public void open();\n    public void print(String s);\n    public void close();\n}\n//定义HPPrinter去implements Printer接口\nclass HPPrinter implements Printer{\n    @Override\n    public void open(){\n        System.out.println(\"HPPrinter open\");\n    }\n    public void print(String s){\n        System.out.println(\"HPPrinter print:\" + s);\n    }\n    public void close(){\n        System.out.println(\"HPPrinter close\");\n    }\n}\n//定义CanonPrinter去implements Printer接口\nclass CanonPrinter implements Printer{\n    @Override\n    private void clean(){\n        System.out.println(\"clean\");\n    }\n    public void open(){\n        System.out.println(\"CanonPrinter open\");\n    }\n    public void print(String s){\n        System.out.println(\"CanonPrinter print:\" + s);\n    }\n    public void close(){\n        this.clean();\n        System.out.println(\"CanonPrinter close\");\n    }\n}\n//静态工厂方法模式\nclass PrinterFactory{\n//定义一个静态函数getPrinter(int flag)，返回值类型为Printer\n    public static Printer getPrinter(int flag){\n        Printer printer = null;\n//根据用户选择生成新的对象，并向上转型为Printer类型\n        if (flag == 0){\n            printer = new HPPrinter();\n        }\n        else if(flag == 1){\n            printer = new CanonPrinter();\n        }\n        return printer;\n    }\n}\n//定义一个主函数，对函数进行调用\nclass Test{\n    public static void main(String args[]){\n        int flag = 1;\n        //工厂方法模式调用 类名+函数\n        Printer printer = PrinterFactory.getPrinter(flag);\n        printer.open();\n        printer.print(\"Test\");\n        printer.close();\n    }\n}\n```\n\n\n## 工厂方法 ##\n#### 简单工厂模式 ####\n\n> Java 简单工厂模式（Simple Factory Pattern）又叫静态工厂方法模式（Static FactoryMethod Pattern），通过专门定义一个类来负责创建其他类的实例（将生成对象的代码封装在工厂类中），被创建的实例通常都具有共同的父类。\n\n\n![](https://raw.githubusercontent.com/roojay520/roojaycloud/images/printer.png)\n\n","tags":["Java"],"categories":["Java"]},{"title":"Java中的变量","url":"%2Fpages%2Fc075d141%2F","content":"\n## 变量的定义\n> 在程序的运行过程中，会产生一些临时数据储存在内存单元中，这每一个内存单元都用一个标识符来标识，这些内存单元被称为变量。\n## 变量的数据类型\n> 变量的数据类型分为两种，即基本数据类型和引用数据类型。\n\n### 1. 基本数据类型 ###\n1. 数值型分为两种：\n\t1.1  整数类型（byte 1字节，short 2字节，int 4字节，long 8字节）\n\t1.2 浮点类型（float 4字节，double 8字节）\n2. 字符型（char）2字节\n3. 布尔型（boolean）1字节\n\n### 2. 引用数据类型 ###\n1. 类（class)\n2. 接口（interface）\n3. 数组\n4. 枚举（enum）\n5. 注解（annotation）\n\n## 变量类型转换 ##\n> 在程序中，当把一种数据类型的值赋值给另一种数据类型时，需要进行数据类型的转换。数据类型转换分为两种：自动类型转换和强制类型转换。\n\n### 1. 自动类型转换 ###\n> 两种数据类型转换不需要显式声明，自动转换类型必须满足两个条件：两种数据类型彼此兼容和转换目标类型的取值范围必须大于原来类型的取值范围。\n1. byte→short，int，long\n2. short，char→int，long\n3. int→long\n4. byte，char，short，int→float\n5. byte，char，short，int，long，float→double\n6. boolean类型无法转换为其他类型。\n\n\n### 2. 强制类型转换 ###\n> 自动转换类型无法进行转换时，进行强制类型转换。取值范围较大的数据类型转换为取值范围较小的类型，可能会造成精度丢失。\n\n例如：\n```java\nint num;\nbyte b =(byte)num;\n```\n","tags":["Java"],"categories":["Java"]},{"title":"Java中的运算符","url":"%2Fpages%2F83e4d5ed%2F","content":"\n## Java中的运算符 ##\n> Java中的运算符分为算术运算符，赋值运算符，比较运算符，逻辑运算符，位运算符。\n\n### 算术运算符 ###\n1. 进行除法运算时，如果除数和被除数都为整得到的结果也会是整数，会忽略小数部分。\n例如：\n```java\n6600/1000*1000\n```\n最后得到的结果为6000。表达式自左至右运算，6600/1000得到6，6*1000=6000。\n\n2. 进行除法运算时如果有小数参与，得到的结果为小数。\n例如：\n```java\n6.6/10\n```\n结果为0.66。\n\n3. 进行取模（%）运算时，运算结果的正负取决于%左边的（被模数）符号有关，与%右边的（模数）的符号无关。\n例如：\n```java\n(-6)/2\n```\n结果为-3。\n```java\n6/(-3)\n```\n结果为2。\n\n### 赋值运算符 ###\n1. 可以通过一条赋值语句对多个变量进行赋值。\n例如：\n```java\nint x, y, z;\nx = y = z = 5;  //为三个变量同时赋值。\n```\n\n2. 使用+=、-=、*=、/=、%=进行赋值时，强制转换类型会自动完成。\n\n### 位运算符 ###\n左移：<<   00000100<<2  00010000     10010001<<2 01000100\n右移：>>   01100010>>2  00011000     11100010>>2 11111000\n无符号右移：     01100010>>>2  00011000     11100010>>>2 00111000\n","tags":["Java"],"categories":["Java"]},{"title":"方法","url":"%2Fpages%2Fad01bc3e%2F","content":"\n> 为解决代码重复编写的问题所设计的特定功能代码块。\n> 方法不能嵌套。\n> main（）方法的作用：调用方法的实例化对象。\n\n方法结构一般为：\n```java\n修饰符 返回值类型 方法名（参数类型 参数1，参数类型 参数2，...）{\n\t执行语句\n\t...\n\t...\n\treturn 返回值；\n}\n```\n### 方法的重载 ###\n> Java 允许在一个程序中定义多个名称相同的方法","tags":["Java"],"categories":["Java"]},{"title":"Java中的数组","url":"%2Fpages%2Fe7882660%2F","content":"\n* 数组是用来存储固定大小的同类型元素。\n\n## 数组的定义方法\n\n### 静态定义法\n\n```java\nint arr [] = {1,5,6,4,};\n```\n\n* arr：整型数组。\n* arr[n]：n为下标，从第0位开始。arr[0]=1, arr[1]=5, arr[2]=6.\n* 数组长度：arr.length.\n\n### 动态定义法\n\n```java\nint arr [] = new int[10];\n```\n\n* 数组的长度为10.\n\n\n### 二维数组的定义方法\n\n```java\n静态定义法：\nint arr[] [] = {{5,3,6},{5,8,7},{6,3,2}};\n动态定义法：\nint arr[] [] = new int[][];\n例：\nint[1][2] = 7;\n```\n\n\n\n","tags":["Java"],"categories":["Java"]},{"title":"Java中的多线程","url":"%2Fpages%2F265f6f6b%2F","content":"\n## 多进程\n在操作系统中能（同时）运行多个任务（程序）。\n\n## 多线程 ##\n在同一应用程序中有多个顺序流（同时）执行。\n![](http://i.imgur.com/svr5BHK.png)\n\n![](http://i.imgur.com/Pw3R29D.png)\n\n## 线程的创建方法 ##\n### 继承Thread类创建多线程 ###\n* 继承Thread类，覆写Thread类的run（）方法，在run（）方法中实现运行在线程上的代码。\n\n1. 定义一个类FirstThread继承Thread类，覆写Thread类的run（）方法；\n2. 生成线程类的对象firstThread；\n3. 启动线程start（）方法。\n\n#### 示例： ####\n```java\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t//生成线程类的对象\n\t\tFirstThread firstThread = new FirstThread();\n\t\t//启动线程start（）方法\n\t\tfirstThread.start();\n\n\t\tfor(int i = 1; i < 50; i++){\n\t\t\tSystem.out.println(\"Main---->:\" + i);\n\t\t}\n\t}\n}\n\n\n//继承Thread类，覆写Thread类的run（）方法\nclass FirstThread extends Thread{\n\tpublic void run(){\n\t\tfor(int i = 1; i < 50; i++){\n\t\t\tSystem.out.println(\"FirstThread--->:\" + i);\n\t\t}\n\t}\n}\n```\n### 实现Runnable接口创建多线程 ###\n* 提供一个实现接口Runnable的类作为线程的目标对象，在初始化一个Thread类或者Thread子类的线程对象时，把目标对象传递给这个线程实例，由该目标对象提供线程体。\n\n1. 定义一个类FirstThread实现Runnable接口；\n2. 生成Runnable实现类FirstThread的一个对象firstThread；\n3. 生成一个Thread对象，并将firstThread作为参数传递给该Thread对象；\n4. 通知Thread对象执行start（）方法。\n\n#### 示例： ####\n```java\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t//生成Runnable实现类FirstThread的一个对象firstThread\n\t\tFirstThread firstThread = new FirstThread();\n\t\t//生成一个Thread对象\n\t\t//并将firstThread作为参数传递给该Thread对象\n\t\tThread thread = new Thread(firstThread);\n\t\t//通知Thread对象执行start（）方法\n\t\tthread.start();\n\n\t\tfor(int i = 1; i <50; i++){\n\t\t\tSystem.out.println(\"Main--->:\" + i);\n\t\t}\n\t}\n}\n\n//实现Runnable接口的类FirstThread\nclass FirstThread implements Runnable{\n\tpublic void run(){\n\t\tfor(int i = 1; i <50; i++){\n\t\t\tSystem.out.println(\"FirstThread--->:\" + i);\n\t\t}\n\t}\n}\n```\n\n\n## 线程的简单控制方法 ##\n\n* 中断线程\n  * Thread.sleep（n毫秒）//当前线程休眠n毫秒\n  * Thread.yield（）//当前线程自动让出CPU，AB重新线程抢占CPU\n\n*  设置线程的优先级\n  *  getPriority（）\n  *  setPriority（）\n    * thread.setPriority(Thread.MAX_PRIORITY) //设置最大优先级为10\n    * thread.setPriority(Thread.MIN_PRIORITY) //设置最小优先级为1\n\n## 同步语法 ##\n### 同步代码块 ###\n\n```java\nsynchronized(this) {   //this：同步锁\n\n\t\t代码块\n}\n```\n* synchronized锁住一个对象。\n* 如果线程A得到同步锁，那么他将可以执行代码块，\n   即使线程B从线程A手中抢到了同步锁，B也不能立即执行代码块，它必须等到线程A执行完这个代码块之后才能执行。\n\n#### 示例 ####\n```java\npublic class Test{\n\tpublic static void main(String args[]){\n\t\tMyThread myThread = new MyThread();\n\t\t//生成两个Thread对象，但是这两个Thread对象共用同一个线程体\n\t\tThread t1 = new Thread(myThread);\n\t\tThread t2 = new Thread(myThread);\n\t\t//通过Thread对象的setName（）方法设置线程名字\n\t\t//使用getName方法获取线程的名字\n\t\tt1.setName(\"线程A\");\n\t\tt2.setName(\"线程B\");\n\t\t//分别启动两个线程\n\t\tt1.start();\n\t\tt2.start();\n\t}\n}\n\nclass MyThread implements Runnable{\n\tint i = 100;\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tsynchronized(this){ //this：同步锁\n\t\t\t\t//Thread.currentThread()获取当前这段代码运行的线程位置\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + i);\n\t\t\t\ti--;\n\t\t\t\tThread.yield();\n\t\t\t\tif(i < 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n### 同步方法 ###\n```java\npublic synchronized void run(){\n\n\t代码块\n}\n\n```\n* synchronized锁住this。\n","tags":["Java"],"categories":["Java"]},{"title":"Java中的I/O流","url":"%2Fpages%2F649b2029%2F","content":"\n## 流的概念和作用\n>\n> 流是数据源到Java程序，Java程序到输出位置之间的管道。\n\n\n## IO流的分类 ##\n>\n1. 根据数据处理类的不同分为：字符流和字节流。\n2. 根据数据流向不同分为：输入流和输出流。\n* 输入输出是以Java程序为参照物的，相对于Java程序本身\n* 输入流：从数据源中读取数据到Java程序中，这个过程称之为输入。\n* 输出流：Java程序将数据写入到其他地方，这个过程称之为输出。\n3. 节点流和处理流。\n4. 节点流：普通的管道；\n5. 处理流：功能性管道，对数据进一步加工。\n\n## 字节流 ##\n### 字节流中的核心类 ###\n\n![](http://i.imgur.com/zhxfDm7.png)\n\n### InputStream ###\n>\n#### int read(byte [] b,int off,int len) ####\nbyte[] b：byte类型数组；\nint off：偏移量；\nint len： 读取数据的量；\n返回值为这次调用read方法读取数据的长度。\n\n### OutputStream ###\n>\n#### void write(byte [] b,int off,int len) ####\nbyte[] b：byte类型数组；\nint off：偏移量；\nint len： 写入数据的量；\n\n\n### 程序步骤 ###\n\n1. 导入类 java.io.*；\n2. 定义主函数；\n3. 声明输入流的引用；\n4. 声明输出流的引用；\n```java\ntry{\n  1.生成代表输入流的对象；\n  2.生成代表输出流的对象；\n  3. 生成一个byte字节数组；\n  4.调用输入流的read方法读取数据；\n  5.定义临时变量接受数据的量；\n  6.调用输出流的write方法写入数据；\n}\ncatch(Exception e){\n\tSysten.out.println(e);\n}\n//finally进行结尾处理\nfinally{\n\ttry{\n\t\tfis.close();\n\t\tfos.close();\n\t}\n\tcatch(Exception e){\n\t\tSystem.out.println(e);\n\t}\n}\n```\n#### 示例 1：\n```java\nimport java.io.*;\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t//声明输入流引用\n\t\tFileInputStream fis = null;\n\t\t//声明输出流引用\n\t\tFileOutputStream fos = null;\n\t\ttry{\n\t\t\t//生成代表输入流的对象\n\t\t\tfis = new FileInputStream(\"D:/java/8.8/from.txt\");\n\t\t\t//生成代表输入流的对象\n\t\t\tfos = new FileOutputStream(\"D:/java/8.8/to.txt\");\n\t\t\t//生成一个字节型buffer数组\n\t\t\tbyte[] buffer = new byte[100];\n\t\t\t//定义一个临时变量，用于接受调用输入流read方法读取数据的量\n\t\t\tint temp = fis.read(buffer,0,b.length);\n\t\t\t//调用输出流的write方法写入数据\n\t\t\tfos.write(buffer,0,temp);\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\t\t//finally进行结尾处理\n\t\tfinally{\n\t\t\ttry{\n\t\t\t\tfis.close();\n\t\t\t\tfos.close();\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\tSystem.out.println(e);\n\t\t\t}\n\t\t}\n}\n```\n\n\n\n## 大文件的读写 ##\n1. 调节buffer数组的大小；\n2. 对read，write方法采取while循环；\n\n#### 示例 2：\n\n```java\nwhile(true){\n\tint temp = fis.read(buffer,0,buffer.length);\n\tif(temp == -1){\n\t\tbreak;\n\t}\n\tfos.write(buffer,0,temp);\n}\n```\n\n## 字符流 ##\n\n* 字符流：是以对写文件时，以字符为基础\n* 字节输入流：Reader <--FileReader\n    * int read(char [] c, int off, int length )\n* 字节输出流：Writer  <--FileWriter\n    * void writer(char [] c, int off, int length)\n\n#### 示例 3：\n```java\nimport java.io.*;\npublic class TestChar{\n\tpublic static void main(String args[]){\n\t\tFileReader fr = null;\n\t\tFileWriter fw = null;\n\t\ttry{\n\t\t\tfr = new FileReader(\"d:/java/9.5/read.txt\");\n\t\t\tfw = new FileWriter(\"d:/java/9.5/write.txt\");\n\t\t\tchar [] buffer = new char[1024];\n\t\t\twhile(true){\n\t\t\t\tint temp = fr.read(buffer, 0, buffer.length);\n\t\t\t\tif(temp == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfw.write(buffer, 0, temp);\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tSystem.out.println(e);\n\t\t}\n\t\tfinally{\n\t\t\ttry{\n\t\t\t\tfr.close();\n\t\t\t\tfw.close();\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\tSystem.out.println(e);\n\t\t\t}\n\t\t}\n\t}\n}\n```","tags":["Java"],"categories":["Java"]},{"title":"处理流与Decorator模式","url":"%2Fpages%2Fbbf344f6%2F","content":"\n## 处理流 ##\n### BufferedReader\n![](http://i.imgur.com/oGh5e2r.png)\n * readeLine：每次读取一行数据\n  ![](http://i.imgur.com/DqMcSrm.png)\n\n#### 示例： ####\n```java\nimport java.io.*;\npublic class Test{\n\tpublic static void main(String args[]){\n\t\tFileReader filereader = null;\n\t\tBufferedReader bufferedreader = null;\n\t\ttry{\n\t\t\tfilereader = new FileReader(\"C:/Users/Jay/Desktop/9.6/src1/read.txt\");\n\t\t\tbufferedreader = new BufferedReader(filereader);\n\t\t\tString line = null;\n\t\t\twhile(true){\n\t\t\t\tline = bufferedreader.readLine();\n\t\t\t\tif(line == null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\n\t\t}\n\t\tcatch(Exception e){\n\t\t\tSystem.out.println(e);\n\t\t}\n\t\tfinally{\n\t\t\ttry{\n\t\t\t\tfilereader.close();\n\t\t\t\tbufferedreader.close();\n\t\t\t}\n\t\t\tcatch(Exception e){\n\t\t\t\tSystem.out.println(e);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n## Decorator（装饰者）模式 ##\n![](http://i.imgur.com/arkDK8p.png)\n#### 示例： ####\n```java\ninterface Teacher{\n\tpublic void teaching();\n}\n\nclass MathTeacher implements Teacher{\n\tpublic void teaching(){\n\t\tSystem.out.println(\"我是一名数学老师\");\n\t}\n}\n\nclass ChineseTeacher implements Teacher{\n\tpublic void teaching(){\n\t\tSystem.out.println(\"我是一名语文老师\");\n\t}\n}\n\nclass ATeacher implements Teacher{\n\tprivate Teacher teacher;\n\tpublic ATeacher(Teacher teacher){\n\t\tthis.teacher = teacher;\n\t}\n\tpublic void teaching(){\n\t\tSystem.out.println(\"你好，我来自ASchool\");\n\t\tteacher.teaching();\n\t}\n}\n\npublic class Test{\n\tpublic static void main(String args[]){\n\t\tMathTeacher mathTeacher = new MathTeacher();\n\t\tATeacher aTeacher1 = new ATeacher(mathTeacher);\n\t\taTeacher1.teaching();\n\n\n\t\tChineseTeacher chineseTeacher = new ChineseTeacher();\n\t\tATeacher aTeacher2 = new ATeacher(chineseTeacher);\n\t\taTeacher2.teaching();\n\t}\n}\n```","tags":["Java"],"categories":["Java"]},{"title":"类集框架","url":"%2Fpages%2F85b5073b%2F","content":"\n* 类集框架是一组类和接口；\n\n* 位于java.until包当中；\n\n* 主要用于存储盒管理对象；\n\n* 主要分为三大类：集合(Set)、列表(List)和映射(Map)。\n\n  ## 类集框架的主体结构\n\n  * Collection为单列集合，Map为双列集合。\n\n  ## ![](http://i.imgur.com/wEVxtzg.png)\n\n\n## Collection接口中的方法\n\n| 方法                    | 功能                   |\n| --------------------- | -------------------- |\n| boolean add（Object o） | 向集合中加入一个对象。          |\n| void clear（）          | 删除集合当中的所有对象。         |\n| boolean  isEmpty（）    | 判断集合是否为空，如果为空返回true。 |\n| remove（Object o）      | 从集合中删除一个对象的引用。       |\n| int size（）            | 返回集合中元素的数目。          |\n\n## Iterator接口\n\n* 主要用于迭代访问（即遍历）整个Collection中的元素，因此Iterator对象也被称为迭代器。\n\n| 方法       | 作用                              |\n| -------- | ------------------------------- |\n| hasNet() | 判断当前迭代器中是否还有下一个元素，返回值为boolean值。 |\n| next()   | 返回当前迭代器下一个元素。                   |\n\n### 示例：\n\n```java\n\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Iterator;\npublic class TestIterator{\n\tpublic static void main(String args[]){\n\t\tSet<String> set = new HashSet<String>();\n\t\tset.add(\"a\");\n\t\tset.add(\"b\");\n\t\tset.add(\"c\");\n\t\tset.add(\"d\");\n\t\tset.add(\"e\");\n\t\t//调用Set对象的Iterator方法生成一个迭代器对象，该对象遍历整个Set\n\t\tIterator<String> it = set.iterator();\n      \t//判断Set集合中是否存在下一个元素\n\t\twhile(it.hasNext()){\n          \t//取出Set集合中的元素\n\t\t\tString s = it.next();\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}\n```\n\n## ListIterator接口\n\n* 可以按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。\n\n| 方法                    | 功能                             |\n| --------------------- | ------------------------------ |\n| void add(Object o)    | 将指定的元素插入列表。                    |\n| boolean hasPrevious() | 如果以逆向遍历列表，列表迭代器有多个元素，则返回true。  |\n| Object previous()     | 返回列表中的前一个元素。                   |\n| void remove()         | 从列表中移除由next或previous返回的最后一个元素。 |\n\n### 示例：\n\n```java\nimport java.util.*;\npublic class Test{\n\tpublic static void main(String args[]) {\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\tlist.add(\"Monday\");\n\t\tlist.add(\"Tuesday\");\n\t\tlist.add(\"Wednesday\");\n\t\tlist.add(\"Thursday\");\n\t\tSystem.out.println(list);\n\t\t//生成一个ListIterator对象\n\t\tListIterator it = list.listIterator(list.size());\n      \t//调用hasPrevious()方法判断是否存在元素\n\t\twhile(it.hasPrevious()){\n          \t//调用previous()方法返回元素\n\t\t\tObject obj = it.previous();\n\t\t\tSystem.out.println(obj);\n\t\t}\n\t}\n}\n```\n\n## 集合（Set）\n\n- 集合中的对象不按特定方式排序，并且没有重复对象。\n\n## HashSet集合\n\n* HashSet是Set接口的一个实现类，它所储存的元素时不可重复且无序的。根据对象的哈希值来确定元素在集合中的储存位置，因此具有良好的存取和查找性能。\n\n### 示例：\n\n```java\nimport java.util.Set;\nimport java.util.HashSet;\npublic class TestSet{\n\tpublic static void main(String args[]){\n\t\t//生成HashSet对象并向上转型为Set\n\t\tSet<String> set =new HashSet<String>();\n\t\t//定义一个boolean型变量b1接受 isEmpty（）方法返回值\n\t\tboolean b1 = set.isEmpty();\n\t\tSystem.out.println(b1);\n\t\tset.add(\"a\");\n\t\tset.add(\"b\");\n\t\tset.add(\"c\");\n\t\tset.add(\"d\");\n\t\tset.add(\"e\");\n\t\tset.add(\"f\");\n\n\t\tboolean b2 =set.isEmpty();\n\t\tSystem.out.println(b2);\n\n\t\t//调用size（）方法获取集合长度\n\t\tint i =set.size();\n\t\tSystem.out.println(\"初始状态set集合中元素的数目\" + i);\n\n\t\t//调用remove（）方法移除对象d\n\t\tset.remove(\"d\");\n\n\t\tint j = set.size();\n\t\tSystem.out.println(\"处理之后set集合中元素的数目\" + j);\n\t}\n}\n```\n\n## TreeSet集合\n\n* 它内部采用自平衡点排序二叉树来储存元素，这样的结构保证TreeSet集合没有重复的元素，并且可以对元素进行排序。\n\n### 二叉树\n\n* 二叉树是指每个节点最多有两个子节点的有序树，每个节点及其子节点组成的树称为子树，通常左侧的节点称为“左子树”，右侧的的子节点称为“右子树”。\n\n![](http://i.imgur.com/TmqrdF9.png)\n\n### 示例：\n\n````java\nimport java.util.*;\npublic class Test01{\n\tpublic static void main(String args[]){\n\t\t//创建TreeSet集合\n\t\tTreeSet<String> ts = new TreeSet<String>();\n\t\tts.add(\"10\");\n\t\tts.add(\"50\");\n\t\tts.add(\"20\");\n\t\tts.add(\"40\");\n\t\tts.add(\"30\");\n\t\t//获取Iterator对象\n\t\tIterator it = ts.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tSystem.out.println(it.next());\n\t\t}\n\t}\n}\n````\n\n结果：\n![](http://i.imgur.com/Wl5KRxh.png)\n\n\n\n## 列表（List）\n\n- 集合中对象按照索引位置排序，即元素的存入和取出顺序一致，可以有重复对象。\n\n## ArrayList\n\n* ArrayList的底层是使用一个数组来保存元素，当增加或删除指定位置的元素时，会创建新的数组，效率较低，因此不适合做大量的增删操作。但是这种数组的结构允许程序通过索引的方式来访问元素，因此使用ArryList集合查找元素很便捷。\n\n### 示例：\n\n```java\nimport java.util.List;\nimport java.util.ArrayList;\npublic class Test{\n\tpublic static void main(String args[]){\n\t\tArrayList<String> arrayList = new ArrayList<String>();\n\t\t//向ArrayList中存入数据\n\t\tarrayList.add(\"a\");\n\t\tarrayList.add(\"b\");\n\t\tarrayList.add(\"c\");\n\t\tarrayList.add(\"d\");\n\n\t\t//移除这个对象\n\t\tarrayList.remove(2);\n\n\t\t//从ArrayList中取数据\n\t\tfor(int i = 0; i < arrayList.size(); i++){\n\t\t\tString s = arrayList.get(i);\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}\n```\n\n## LinkedList\n\n* 内部维护了一个双向循环链表，链表中的每一个元素都使用引用的方式来记住它的前一个元素和后一个元素，插入一个新元素，只需修改元素之间的这种引用关系即可。\n\n### 示例：\n\n```java\nimport java.util.List;\nimport java.util.LinkedList;\npublic class Test01{\n\tpublic static void main(String args[]){\n\t\t//创建LinkedList集合\n\t\tLinkedList<String> link = new LinkedList<String>();\n\t\t\t//向集合中添加元素\n\t\t\tlink.add(\"One\");\n\t\t\tlink.add(\"Two\");\n\t\t\tlink.add(\"Three\");\n\t\t\tlink.add(\"Four\");\n\t\t\t//取出并打印该集合中的所有元素\n\t\t\tSystem.out.println(link.toString());\n\t\t\t//向指定位置插入元素\n\t\t\tlink.add(2,\"插个队\");\n\t\t\tSystem.out.println(link);\n\t\t\t//移除指定位置的元素\n\t\t\tlink.remove(2);\n\t\t\tSystem.out.println(link);\n\t}\n}\n```\n\n## 映射（Map）\n\n- 集合中的每一个元素包含一个键对象和一个值对象，键不可重复，值可以重复。\n\n| 键对象  |  值对象   |\n| :--: | :----: |\n| key1 | value1 |\n| key2 | value2 |\n| key3 | value3 |\n\n## Map接口中的方法\n\n| 方法                              | 作用                                  |\n| ------------------------------- | ----------------------------------- |\n| void clear()                    | 从此映射中移除所有映射关系（可选操作）。                |\n| boolean containsKey（Object Key） | 如果此映射包含指定键的映射关系，则返回 true。           |\n| boolean equals（Object o）        | 比较指定的对象与此映射是否相等。                    |\n| get（Object key）                 | 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回null。 |\n| boolean isEmpty（）               | 如果此映射未包含键-值映射关系，则返回 true。           |\n| put（）                           | 将指定的值与此映射中的指定键关联。                   |\n| remove（Object key）              | 如果存在一个键的映射关系，则将其从此映射中移除。            |\n| int size（）                      | 返回此Map中的键值对数目。                      |\n\n## Map与HashMap\n\n### 示例：\n\n```java\nimport java.util.Map;\nimport java.util.HashMap;\npublic class Test{\n\tpublic static void main(String args[]){\n\t\t//生成HashMap对象并向上转型为Map\n\t\tMap<String,String> map = new HashMap<String,String>();\n\t\t//向map中添加键值对\n\t\tmap.put(\"1\",\"One\");\n\t\tmap.put(\"2\",\"Two\");\n\t\tmap.put(\"3\",\"Three\");\n\t\t//调用get（Object key）方法，返回指定键所映射的值；\n\t\t//如果对于该键来说，此映射不包含任何映射关系，则返回 null。\n\t\tString s = map.get(\"2\");\n\t\tSystem.out.println(s);\n\t}\n}\n```\n\n\n\n","tags":["Java"],"categories":["Java"]},{"title":"结构语句","url":"%2Fpages%2F1c7ee7be%2F","content":"\n## 选择结构语句\n\n### if条件语句\n\n> 当判断条件1结果为true时，执行语句1，为false时，执行语句2。当判断条件1,2都不满足true时，执行语句3。\n\n例如：\n```java\nif (判断条件1){\n  执行语句1\n}\nelse if(判断条件2){\n  执行语句2\n}\nelse{\n  执行语句3\n}\n```\n\n### 三元运算 ###\n> 一种类似于if-else语句的运算，三元运算一般会得到一个结果，一般用来对某个变量进行赋值。\n> 当判断条件成立时结果为表达式1的值，否则表达式2的值。\n```java\n判断条件 ? 表达式 1 : 表达式 2\n```\n\n例如：求取两个数x，y中较大的值。\n```java\n//if-else实现方法\nint x, y, max;\nif(x>y){\n\tmax = x;\n}\nelse{\n\tmax = y;\n}\n\n//三元运算实现\nint x, y, max;\nmax = x > y ? x : y;\n\n```\n\n### switch语句\n\n> 在switch语句中使用switch关键字来描述一个表达式，使用case关键字来描述和表达式结果比较的目标值，\n> 当表达式的值和某个目标值匹配时，会执行对应case下的语句。\n\n例如：\n```java\nswitch(表达式){\n  case 1:\n    执行语句1;\n       break; //break终止case并跳出switch循环\n  case 2:\n    执行语句2;\n     break;\n  case 3:\n    执行语句3；\n      break;\n  default: //default处理和前面的case都不匹配的值\n    执行语句4;\n      break;\n}\n```\n\n## 循环结构语句\n\n### while循环语句\n\n> 循环条件判断为true时，执行语句循环执行，直到循环条件为false。\n\n例如：\n```java\nwhile(循环条件){\n\t执行语句\n}\n```\n\n### do...while循环语句\n\n> 循环体会无条件执行一次，然后根据循环条件决定是否继续执行。\n\n例如：\n```java\ndo{\n  执行语句\n}\nwhile(循环条件);\n```\n\n### for循环语句\n\n> 一般用在循环次数已知的情况下，循环条件判断为true执行顺序①→②→④→③\n\n例如：\n```java\nfor(初始化表达式①;循环条件②;操作表达式③){\n  执行语句④\n}\n```\n\n```java\n/**\n * Created by Roojay on 2017/4/7.\n * 利用嵌套循环打印一个正三角形。\n */\npublic class Test1 {\n    public static void main(String args[]){\n        int i, j, k;\n        for(i = 1; i <= 5; i++){\n            for(k = 0; k < 5 - i; k++){\n                System.out.print(\" \");\n            }\n            for(j = 1; j <= i; j++){\n                System.out.print(\"* \");\n            }\n\n            System.out.println();\n        }\n\n    }\n}\n```\n\n### 跳转语句\n\n#### break语句\n\n> 当它出现在switch条件语句中时，作用是终止某个case并跳出switch结构。\n> 当它出现在循环语句中，作用是跳出循环语句，执行后面的代码。\n> 当它出现在嵌套循环内层循环中时，只能跳出内层循环，如果想跳出外层循环，\n> 需要对外层前面添加标记 itcast： ，在后面使用 break itcast 跳出外层循环。\n\n#### continue语句\n\n> continue语句用在循环语句中，它的作用是终止本次循环，执行下一次循环。\n> 也可以使用标记结束外循环。","tags":["Java"],"categories":["Java"]},{"title":"进制转换","url":"%2Fpages%2F7dc91154%2F","content":"\n### 十进制转换二进制\n> 将一个十进制数转换为二进制，就是将这个数不断取余的过程，将这个数除以 2，得到了商和余数，然后将商不断除以 2，直到商为 0，然后将余数倒过来排列，所得到的数就是转换的二进制结果。\n###  二进制转八进制\n>将二进制数自右向左每三位分成一段，然后将每三位数转换为一位八进制数。\n\n 例如：111000101 = 111 000 101 = 0 7 0 5\n 八进制以 0 开头。\n\n### 二进制转十六进制\n> 将二进制数自右向左每四位分成一段，然后将每四位转换为一位十六进制数。\n\n例如：111010100110=1110 1010 0110=0x E A 6\n 十六进制以 0x 或者 0X 开头。\n\n","tags":["Java"],"categories":["Java"]},{"title":"获取键盘输入","url":"%2Fpages%2F828295ba%2F","content":"\n```java\n/**\nJava获取键盘输入值\n*/\npublic static void main(String args[]){\n  Scanner sc = new Scanner(Systen.in);\n  String s = sc.nextLine(); //接受字符和字符串类型的输入\n  int age = sc.nextInt();\n  float salary = sc.nextFloat();\n}\n```\n\n#### 简单运行、退出方法\n\n```java\nimport java.util.Scanner;\npublic class Test {\n\tpublic static void main(String args[]) {\n\t\tint t = 1;\nitcast :\n\t\twhile(t > 0) {\n\t\t\tSystem.out.println(\"1.运行：\\n\" + \"2.退出：\");\n\t\t\tScanner sc1 = new Scanner(System.in);\n\t\t\tint i = sc1.nextInt();\n\t\t\tswitch(i) {\n\t\t\tcase 1:\n\t\t\t\t//这里输入具体的计算程序\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbreak itcast;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"输入有误，请重新输入\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n","tags":["Java"],"categories":["Java"]},{"title":"CodeTest","url":"%2Fpages%2F24709d34%2F","content":"\n```java\npublic class CodeTest{\n  public static void main(String args[]){\n    system.out.println(\"Hello Hexo!\")\n  }\n}\n```\n\n","tags":["Test"]},{"title":"Test","url":"%2Fpages%2F784dd132%2F","content":"1. $ hexo new \"My New Post\"\n2. $ hexo server\n3. $ hexo generate\n4. $ hexo deploy \n","tags":["test"]}]